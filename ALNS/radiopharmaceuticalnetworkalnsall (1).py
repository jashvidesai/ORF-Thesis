# -*- coding: utf-8 -*-
"""RadiopharmaceuticalNetworkALNSALL.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1K4vHVANZKxtk1l5IHr3xhoGF9sG6sp54

# **Importing From RadiopharmaceuticalNetworkParameters.ipynb**
"""

from google.colab import drive
drive.mount('/content/drive')

# Commented out IPython magic to ensure Python compatibility.
# %run ./RadiopharmaceuticalNetworkParameters.ipynb

"""# **Initial Algorithm**"""

class Vehicle:
    def __init__(self, vehicle_id, capacity, speed, cost, depot):
        self.vehicle_id = vehicle_id # unique ID for each vehicle
        self.capacity = capacity #
        self.speed = speed
        self.cost = cost # fixed cost of vehicle
        self.route = [(depot, 0, 0, 0.0)] # (customer_id, delivered, picked_up, arrival_time), starts at depot
        self.current_time = 0

        # Updated Capacity Tracking
        self.full_vials = int(self.capacity * 0.75) # Start with 75% full vials
        self.empty_vials = 0 # Initially no empty vials
        self.empty_space = self.capacity - (self.full_vials + self.empty_vials) # Available space
        self.current_location = depot

    def can_add_customer(self, node, travel_time):
        """
        Check if the vehicle can arrive within the time window.
        Returns (boolean) feasibility flag and expected arrival time.
        """
        # check if the vehicle has capacity
        if self.empty_vials == self.capacity:
            return False, self.current_time # vehicle is full with pickups, can't serve more

        arrival_time = self.current_time + travel_time
        if arrival_time > b[node]: # Too late
            return False, arrival_time
        if arrival_time < a[node]: # Arrive early, wait
            arrival_time = a[node]
        return True, arrival_time

    def add_customer(self, node, delivery_demand, pickup_demand, travel_time):
        """
        Assigns a customer to the vehicle while ensuring delivery before pickup
        and allowing split deliveries.
        """
        # Step 1: Check feasibility (time window constraints)
        feasible, arrival_time = self.can_add_customer(node, travel_time)
        if not feasible:
            return False, delivery_demand, pickup_demand

        # Step 2: Deliver first, and update the vehicle load values
        delivered = min(self.full_vials, delivery_demand)
        self.full_vials -= delivered
        delivery_demand -= delivered
        self.empty_space = self.capacity - (self.full_vials + self.empty_vials)

        # Step 3: Pick up second, and update the vehicle load values
        picked_up = min(self.empty_space, pickup_demand)
        self.empty_vials += picked_up
        pickup_demand -= picked_up
        self.empty_space = self.capacity - (self.full_vials + self.empty_vials)

        # Step 4: Save customer in route & update time
        self.route.append((int(node), int(delivered), int(picked_up), float(arrival_time)))
        self.current_time = arrival_time + s[node]
        self.current_location = node

        # Print Statements
        print(f"Vehicle {self.vehicle_id} visited Customer {node}:")
        print(f"   - Delivered {delivered} (Remaining at customer: {delivery_demand})")
        print(f"   - Picked Up {picked_up} (Remaining at customer: {pickup_demand})")
        print(f"   - Vehicle State: Full Vials = {self.full_vials}, Empty Vials = {self.empty_vials}, Empty Space = {self.empty_space}")


        return True, delivery_demand, pickup_demand

    def return_to_depot(self, depot, t, depot_service_time=30):
        """
        Sends the vehicle back to the depot when full of empty vials.
        Resets load and allows for redeployment.
        """
        if self.current_location == depot:
            return
        travel_time_to_depot = t[self.current_location][depot] # Retrieve from travel time matrix
        self.route.append((depot, 0, 0, self.current_time + travel_time_to_depot)) # Add depot return
        self.current_time += travel_time_to_depot + depot_service_time # Add travel and depot service time

        # Reset vehicle load: Start with 75% full vials, empty vials reset to 0
        self.full_vials = int(self.capacity * 0.75)
        self.empty_vials = 0
        self.empty_space = self.capacity - (self.full_vials + self.empty_vials)

        print(f"Vehicle {self.vehicle_id} returned to depot at time {self.current_time} and reset.")

# visiting order is based on distance to depot
def compute_ordered_route(V_star, depot, distances):
    """
    Computes a heuristic visiting order:
    1. Start with the farthest customer from the depot.
    2. Sequentially add the nearest unvisited customer.
    """
    if not V_star:
        return []

    start_node = max(V_star, key=lambda c: distances[depot][c]) # Start with farthest
    ordered_route = [start_node]
    remaining_nodes = set(V_star) - {start_node}

    while remaining_nodes:
        last_node = ordered_route[-1]
        next_node = min(remaining_nodes, key=lambda c: distances[last_node][c]) # Nearest neighbor
        ordered_route.append(next_node)
        remaining_nodes.remove(next_node)

    return ordered_route

# compute a new ordered route based on proximity to depot (after depot service)
def compute_nearest_ordered_route(V_star, depot, distances):
    """
    Computes a heuristic visiting order:
    1. Start with the closest customer to the depot.
    2. Sequentially add the nearest unvisited customer.
    """
    if not V_star:
        return []

    start_node = min(V_star, key=lambda c: distances[depot][c]) # Start with nearest
    ordered_route = [start_node]
    remaining_nodes = set(V_star) - {start_node}

    while remaining_nodes:
        last_node = ordered_route[-1]
        next_node = min(remaining_nodes, key=lambda c: distances[last_node][c]) # Nearest neighbor
        ordered_route.append(next_node)
        remaining_nodes.remove(next_node)

    return ordered_route

# generates a full solution using the sequential deployment
def generate_sequential_solution(V, V_star, K, Q, d, p, a, b, s, t, depot, distances):
    """
    Deploys vehicles sequentially, prioritizing larger vehicles first.
    If a vehicle is redeployed, it follows a new nearest-neighbor order.
    """
    initial_ordered_route = compute_ordered_route(V_star, depot, distances) # Initial farthest-first order

    # Deploy largest vehicles first
    vehicles = sorted(
        [Vehicle(k, Q[k], vehicle_speed, fixed_costs[k], depot) for k in K],
        key=lambda v: v.capacity,
        reverse=True
    )

    remaining_deliveries = {i: d[i] for i in V_star} # dictionary to track remaining delivery demand
    remaining_pickups = {i: p[i] for i in V_star} # dictionary to track remaining pickup demand

    for vehicle in vehicles:
        print(f"\nDeploying Vehicle {vehicle.vehicle_id} (Capacity {vehicle.capacity})\n")

        current_route = initial_ordered_route[:]

        while True: # Keep redeploying the vehicle until it can’t serve any more customers
            all_customers_served = True # Flag to check if all customers are served

            # skips if fully served
            for customer in current_route[:]:
                if remaining_deliveries[customer] == 0 and remaining_pickups[customer] == 0:
                    continue

                success, new_remaining_delivery, new_remaining_pickup = vehicle.add_customer(
                    customer, remaining_deliveries[customer], remaining_pickups[customer],
                    t[vehicle.current_location][customer]
                )

                if not success:
                    break

                remaining_deliveries[customer] = new_remaining_delivery
                remaining_pickups[customer] = new_remaining_pickup
                all_customers_served = False # At least one customer was served

            vehicle.return_to_depot(depot, t, depot_service_time=30) # 30-min depot service time

            # Check if there are still unfulfilled customers
            if all_customers_served:
                break # No point in redeploying, so exit

            # Compute a new order for redeployment based on nearest-first heuristic
            unserved_customers = [i for i in V_star if remaining_deliveries[i] > 0 or remaining_pickups[i] > 0]
            current_route = compute_nearest_ordered_route(unserved_customers, depot, distances)

    return vehicles, remaining_deliveries, remaining_pickups

# removes consectuive depot visits
def clean_up_route(route):
    cleaned = []
    for i in range(len(route)):
        if i > 0 and route[i][0] == 0 and route[i - 1][0] == 0:
            continue
        cleaned.append(route[i])
    return cleaned

# print function
def print_vehicle_routes_with_costs(vehicles, c):
    total_travel_cost = 0
    total_fixed_cost = 0

    print("\nUSED VEHICLE ROUTES & COSTS:")

    for vehicle in vehicles:
        route = clean_up_route(vehicle.route)
        is_used = len(route) > 1

        # Add fixed cost regardless of use
        total_fixed_cost += vehicle.cost

        travel_cost = 0
        if is_used:
            for i in range(len(route) - 1):
                from_node = route[i][0]
                to_node = route[i + 1][0]
                travel_cost += c[from_node][to_node]
            total_travel_cost += travel_cost

            formatted_route = [(int(n), int(d), int(p), float(round(t, 1))) for (n, d, p, t) in route]
            print(f"Vehicle {vehicle.vehicle_id}: Route {formatted_route}, Travel Cost: {round(travel_cost, 2)}")
        else:
            print(f"Vehicle {vehicle.vehicle_id}: UNUSED (Fixed Cost still included)")

    grand_total = total_fixed_cost + total_travel_cost

    print("\nTOTAL COST BREAKDOWN:")
    print(f"  Fixed Cost (All Vehicles): {round(total_fixed_cost, 2)}")
    print(f"  Travel Cost (Used Vehicles): {round(total_travel_cost, 2)}")
    print(f"  Grand Total Cost: {round(grand_total, 2)}")

    return {
        "fixed_cost": round(total_fixed_cost, 2),
        "travel_cost": round(total_travel_cost, 2),
        "total_cost": round(grand_total, 2)
    }

# Run the updated solution
vehicles_updated, remaining_deliveries, remaining_pickups = generate_sequential_solution(
    V, V_star, K, Q, d, p, a, b, s, t_matrix_np, depot=0, distances=distance_matrix_np
)

print("\n✅ Demand Satisfaction Check")
unsatisfied_deliveries = {cust: amt for cust, amt in remaining_deliveries.items() if amt > 0}
unsatisfied_pickups = {cust: amt for cust, amt in remaining_pickups.items() if amt > 0}

if not unsatisfied_deliveries and not unsatisfied_pickups:
    print("All customer demands are satisfied!")
else:
    print("Some customer demands remain unsatisfied!")
    if unsatisfied_deliveries:
        print("Remaining Deliveries:", unsatisfied_deliveries)
    if unsatisfied_pickups:
        print("Remaining Pickups:", unsatisfied_pickups)

print("\n**Vehicle Routes with Costs**")
print_vehicle_routes_with_costs(vehicles_updated, c_matrix_np)

"""# **Removal Operators**

# Random Removal

Random removal simply randomly selects a subset of customers from the current solution.
"""

def random_removal(solution, p, original_deliveries, original_pickups, t, s):
    modified_solution = deepcopy(solution)
    all_customers = set()

    # Step 1: Identify all customers
    for vehicle in modified_solution:
        for stop in vehicle.route:
            if stop[0] != 0:
                all_customers.add(stop[0])

    # Step 2: Randomly select customers to remove
    num_to_remove = int(p * len(all_customers))
    customers_to_remove = random.sample(list(all_customers), min(num_to_remove, len(all_customers)))

    # Step 3: Remove those customers from all routes
    for vehicle in modified_solution:
        vehicle.route = [stop for stop in vehicle.route if stop[0] not in customers_to_remove]

    # Step 4: Initialize updated demand with original values
    updated_deliveries = {i: original_deliveries[i] for i in original_deliveries}
    updated_pickups = {i: original_pickups[i] for i in original_pickups}

    print("Removed Customers:", sorted(customers_to_remove))

    return modified_solution, customers_to_remove, updated_deliveries, updated_pickups

# Random Removal Example
original_d = deepcopy(d)
original_p = deepcopy(p)

original_d = {i: d[i] for i in range(len(d))}
original_p = {i: p[i] for i in range(len(p))}

modified_random, removed_random, updated_deliveries, updated_pickups = random_removal(
    vehicles_updated, 0.3, original_d, original_p, t_matrix_np, s
)

"""# Related Removal

Related removal selects a seed customer at random and removes the customers located closest to it.
"""

# Related Removal
def related_removal(solution, p, original_deliveries, original_pickups, t, s, distances):
    modified_solution = deepcopy(solution)
    all_customers = set()

    # Step 1: Identify all customers in the solution (excluding depot)
    for vehicle in modified_solution:
        for stop in vehicle.route:
            if stop[0] != 0:
                all_customers.add(stop[0])

    if not all_customers:
        return modified_solution, [], original_deliveries, original_pickups

    # Step 2: Choose a seed and identify similar customers (close spatially)
    num_to_remove = int(p * len(all_customers))
    seed_customer = random.choice(list(all_customers))
    related_customers = sorted(all_customers, key=lambda c: distances[seed_customer][c])
    customers_to_remove = related_customers[:min(num_to_remove, len(related_customers))]

    # Step 3: Remove customers from routes
    for vehicle in modified_solution:
        vehicle.route = [stop for stop in vehicle.route if stop[0] not in customers_to_remove]

    # Step 4: Reset demand to original
    updated_deliveries = {i: original_deliveries[i] for i in original_deliveries}
    updated_pickups = {i: original_pickups[i] for i in original_pickups}

    print("Removed Customers (Related):", sorted(customers_to_remove))

    return modified_solution, customers_to_remove, updated_deliveries, updated_pickups

# Related Removal Example
original_d = deepcopy(d)
original_p = deepcopy(p)

original_d = {i: d[i] for i in range(len(d))}
original_p = {i: p[i] for i in range(len(p))}

modified_related, removed_related, updated_deliveries, updated_pickups = related_removal(
    vehicles_updated, 0.3, original_d, original_p, t_matrix_np, s, distance_matrix_np
)

"""# Worst Removal

Worst removal removes customers that contribute the most to the total cost of the solution. This is determined by the value associated with the cost reduction achieved by their removal.
"""

# Worst Removal
def worst_removal(solution, p, original_deliveries, original_pickups, t, s, distances, fixed_costs):
    modified_solution = deepcopy(solution)
    all_customers = set()
    customer_total_cost = {}

    # Extract all customers and calculate cost impact
    for vehicle in modified_solution:
        for i, stop in enumerate(vehicle.route):
            if stop[0] != 0:
                all_customers.add(stop[0])

                # Get previous and next stops
                prev_stop = vehicle.route[i - 1] if i > 0 else (0, 0, 0, 0)
                next_stop = vehicle.route[i + 1] if i < len(vehicle.route) - 1 else (0, 0, 0, 0) # Depot if last stop

                # Compute cost impact: added travel distance and vehicle fixed cost
                cost = (
                    distances[prev_stop[0]][stop[0]] +
                    distances[stop[0]][next_stop[0]] -
                    distances[prev_stop[0]][next_stop[0]] +
                    fixed_costs[vehicle.vehicle_id]
                )

                # Aggregate total cost contribution per customer
                customer_total_cost[stop[0]] = customer_total_cost.get(stop[0], 0) + cost

    if not all_customers:
        return modified_solution, [], remaining_deliveries, remaining_pickups

    num_to_remove = int(p * len(all_customers))

    # Sort customers by total cost contribution in descending order
    sorted_customers = sorted(customer_total_cost.items(), key=lambda x: x[1], reverse=True)

    # Extract the highest-cost customers for removal
    customers_to_remove = [customer for customer, _ in sorted_customers[:min(num_to_remove, len(sorted_customers))]]

    # Remove selected customers from all routes
    for vehicle in modified_solution:
        vehicle.route = [stop for stop in vehicle.route if stop[0] not in customers_to_remove]

    # Set remaining demand of removed customers to original
    updated_deliveries = {i: original_deliveries[i] for i in original_deliveries}
    updated_pickups = {i: original_pickups[i] for i in original_pickups}

    print("Removed Customers (Worst):", sorted(customers_to_remove))

    return modified_solution, customers_to_remove, updated_deliveries, updated_pickups

# Worst Removal Example
original_d = deepcopy(d)
original_p = deepcopy(p)

original_d = {i: d[i] for i in range(len(d))}
original_p = {i: p[i] for i in range(len(p))}

modified_worst, removed_worst, updated_deliveries, updated_pickups = worst_removal(
    vehicles_updated, 0.3, original_d, original_p, t_matrix_np, s, distance_matrix_np, fixed_costs
)

"""# **Insertion Operators**

We first define a total cost (objective) function and this will be used to test each insertion operator after it is written to simulate it after a random removal operator is applied to the initial solution.

This function calculates the total cost of a vehicle routing solution by summing the fixed costs of all used vehicles and the travel costs between each pair of consecutive stops in their routes. It only includes vehicles that serve at least one customer (i.e., have more than one stop) and rounds the final cost to two decimal places.
"""

def compute_total_cost(solution, c, fixed_costs):
    total_travel_cost = 0
    total_fixed_cost = 0

    for vehicle in solution:
        # Add fixed cost for all vehicles, used or not
        total_fixed_cost += fixed_costs[vehicle.vehicle_id]

        # Add travel cost only if the vehicle is used
        if len(vehicle.route) > 1:
            for i in range(len(vehicle.route) - 1):
                from_node = vehicle.route[i][0]
                to_node = vehicle.route[i + 1][0]
                total_travel_cost += c[from_node][to_node]

    total_cost = total_fixed_cost + total_travel_cost
    return round(total_cost, 2)

"""# Parallel Insertion

The parallel insertion heuristic reinserts removed customers into existing routes by evaluating all feasible insertion positions across all vehicles, using a priority queue to prioritize low-cost options. It updates vehicle routes and demand fulfillment in a greedy fashion while ensuring adherence to time windows and capacity constraints, and flags customers with any remaining unmet demand for later handling.
"""

# main greedy reinsertion of removed customers using a priority queue based on cost
def core_parallel_insertion(solution, removed_customers, c, t, remaining_deliveries, remaining_pickups, a, b, s):
    insertion_heap = [] # priority queue to store candidate insertions
    retry_customers = set() # track customers with remaining unmet demand after initial insertion

    # Ensure all routes start at depot
    for vehicle in solution:
        if not vehicle.route or vehicle.route[0][0] != 0:
            vehicle.route.insert(0, (0, 0, 0, 0.0))
            vehicle.current_time = 0.0

    # loop over every removed customer, every vehicle, and every possible insertion position
    for customer in removed_customers:
        for vehicle in solution:
            for idx in range(len(vehicle.route) - 1):
                prev_stop = vehicle.route[idx][0] # node before insertion point
                next_stop = vehicle.route[idx + 1][0] # node after insertion point
                prev_arrival_time = vehicle.route[idx][3] # the time the vehicle arrives at the previous stop.

                travel_time = t[prev_stop][customer]
                arrival_time = prev_arrival_time + travel_time # arrival time at the insertion point

                # if arrival time too late skip, else stay (maybe wait)
                if arrival_time > b[customer]:
                    continue
                elif arrival_time < a[customer]:
                    arrival_time = a[customer]

                cost = c[prev_stop][customer] + c[customer][next_stop] - c[prev_stop][next_stop] # insertion cost formula
                max_delivery = min(remaining_deliveries.get(customer, 0), vehicle.full_vials) # how much delivery demand can be satisfied
                predicted_empty_space = vehicle.empty_space + max_delivery # empty space after the delivery is done
                max_pickup = min(remaining_pickups.get(customer, 0), predicted_empty_space) # how much pickup demand can be satisfied

                # if anything can be done, add to the priority queue
                if max_delivery > 0 or max_pickup > 0:
                    heapq.heappush(insertion_heap, (cost, idx, vehicle.vehicle_id, vehicle, customer, max_delivery, max_pickup))

    # process the cheapest insertion
    while insertion_heap:
        _, idx, _, vehicle, customer, delivery, pickup = heapq.heappop(insertion_heap)

        if remaining_deliveries.get(customer, 0) == 0 and remaining_pickups.get(customer, 0) == 0:
            continue # skips if demand is already met

        # final demand check and assign
        assigned_delivery = min(remaining_deliveries[customer], vehicle.full_vials)
        predicted_empty_space = vehicle.empty_space + assigned_delivery
        assigned_pickup = min(remaining_pickups[customer], predicted_empty_space)

        # update the vehicle state
        vehicle.full_vials -= assigned_delivery
        vehicle.empty_vials += assigned_pickup
        vehicle.empty_space = vehicle.capacity - (vehicle.full_vials + vehicle.empty_vials)

        # insert into the route with updated time
        prev_stop = vehicle.route[idx][0]
        prev_time = vehicle.route[idx][3]
        travel_time = t[prev_stop][customer]
        arrival_time = max(prev_time + travel_time, a[customer])
        service_end_time = float(round(arrival_time + s[customer], 2))

        vehicle.route.insert(idx + 1, (customer, assigned_delivery, assigned_pickup, float(round(service_end_time, 2))))

        # shift all later times as a result of adding
        for i in range(idx + 2, len(vehicle.route)):
            prev_stop = vehicle.route[i - 1]
            next_stop = vehicle.route[i][0]
            travel = t[prev_stop[0]][next_stop]
            arrival = max(prev_stop[3] + travel, a[next_stop])
            vehicle.route[i] = (next_stop, vehicle.route[i][1], vehicle.route[i][2], float(round(arrival + s[next_stop], 2)))

        # update demand tracking
        remaining_deliveries[customer] -= assigned_delivery
        remaining_pickups[customer] -= assigned_pickup

        if remaining_deliveries[customer] > 0 or remaining_pickups[customer] > 0:
            retry_customers.add(customer)
        else:
            removed_customers.remove(customer)

    # Final sweep: retry any removed customers who still have unmet demand
    retry_customers = {
        cust for cust in remaining_deliveries
        if remaining_deliveries.get(cust, 0) > 0 or remaining_pickups.get(cust, 0) > 0
        }

    return solution, retry_customers, remaining_deliveries, remaining_pickups

# Recomputes the actual unmet demand from vehicle routes after insertion
def recompute_remaining_demands_from_solution(solution, initial_deliveries, initial_pickups):
    remaining_deliveries = initial_deliveries.copy()
    remaining_pickups = initial_pickups.copy()

    for vehicle in solution:
        for node in vehicle.route:
            cust_id, delivered, picked_up, _ = node
            if cust_id == 0:
                continue # Skip depot
            if cust_id in remaining_deliveries:
                remaining_deliveries[cust_id] -= delivered
            if cust_id in remaining_pickups:
                remaining_pickups[cust_id] -= picked_up

    # Clip negative values to 0 (in case more than expected was served)
    for cust in remaining_deliveries:
        remaining_deliveries[cust] = max(0, remaining_deliveries[cust])
    for cust in remaining_pickups:
        remaining_pickups[cust] = max(0, remaining_pickups[cust])

    return remaining_deliveries, remaining_pickups

# function to apply core_parallel_insertion and final adjustments
def parallel_insertion(solution, removed_customers, c, t, initial_deliveries, initial_pickups, a, b, s):
    deliveries = deepcopy(initial_deliveries)
    pickups = deepcopy(initial_pickups)

    # Step 1: Perform greedy insertion
    parallel_solution, retry_customers, remaining_deliveries, remaining_pickups = core_parallel_insertion(
        solution, removed_customers, c, t, initial_deliveries, initial_pickups, a, b, s)

    # Step 2: Recompute actual remaining demand from final solution
    remaining_deliveries, remaining_pickups = recompute_remaining_demands_from_solution(
        parallel_solution, remaining_deliveries, remaining_pickups
    )

    # Step 3: Final retry set
    retry_customers = {
        cust for cust in remaining_deliveries
        if remaining_deliveries[cust] > 0 or remaining_pickups[cust] > 0
    }

    return solution, retry_customers, remaining_deliveries, remaining_pickups

initial_deliveries = {i: d[i] for i in V_star}
initial_pickups = {i: p[i] for i in V_star}

# Random Removal on Initial Solution
modified_random, removed_random, updated_deliveries, updated_pickups = random_removal(
    deepcopy(vehicles_updated), 0.3, deepcopy(initial_deliveries), deepcopy(initial_pickups), t_matrix_np, s
)

# Parallel Insertion Function on Random Removal
solution, retry_customers, remaining_deliveries, remaining_pickups = parallel_insertion(
    modified_random, removed_random, c_matrix_np, t_matrix_np,
    updated_deliveries, updated_pickups, a, b, s
)

for cust in retry_customers:
        d_amt = remaining_deliveries.get(cust, 0)
        p_amt = remaining_pickups.get(cust, 0)
        print(f"Customer {cust}: Delivery = {d_amt}, Pickup = {p_amt}")

print_vehicle_routes_with_costs(solution, c_matrix_np)

"""# Regret Split Insertion

The regret split insertion heuristic reassigns removed customers by evaluating multiple feasible insertion points across all routes and computing a regret value based on the difference between the best and second-best insertion costs. Customers with higher regret are prioritized for reinsertion, ensuring that opportunities for low-cost insertions are not missed.
"""

# Core Regret Split Insertion
def core_regret_split_insertion(solution, removed_customers, c, t, remaining_deliveries, remaining_pickups, a, b, s):
    insertion_candidates = {} # stores potential insertion positions for each customer
    retry_customers = set() # if a customer has no valid positions, add them here

    # Step 1: Build candidate insertions
    for customer in removed_customers:
        positions = []
        for vehicle in solution:
            # try inserting customer between every two stops
            for idx in range(len(vehicle.route) - 1):
                prev_stop = vehicle.route[idx][0]
                next_stop = vehicle.route[idx + 1][0]
                prev_arrival_time = vehicle.route[idx][3]

                travel_time = t[prev_stop][customer]
                arrival_time = prev_arrival_time + travel_time

                # respect time window constraints
                if arrival_time > b[customer]:
                    continue
                if arrival_time < a[customer]:
                    arrival_time = a[customer]

                # compute max feasible delivery and pickup amounts
                feasible_delivery = min(remaining_deliveries[customer], vehicle.full_vials)
                feasible_pickup = min(remaining_pickups[customer], vehicle.capacity - (vehicle.full_vials + vehicle.empty_vials + feasible_delivery))

                if feasible_delivery == 0 and feasible_pickup == 0:
                    continue

                # compute insertion cost and then the score
                cost = c[prev_stop][customer] + c[customer][next_stop] - c[prev_stop][next_stop]
                served = feasible_delivery + feasible_pickup
                score = cost / served

                positions.append((score, cost, idx, vehicle.vehicle_id, vehicle, feasible_delivery, feasible_pickup))

        # store valid positions or mark customer as uninsertable (for now)
        if positions:
            positions.sort() # sort by score (lowest regret first)
            insertion_candidates[customer] = positions
        else:
            retry_customers.add(customer)

    # Step 2: Regret prioritization of which customers to insert
    regret_heap = []

    # do the regret formula and then sort from max value down
    for customer, options in insertion_candidates.items():

        # Regret value = difference between best and second-best cost
        regret_value = options[1][1] - options[0][1] if len(options) > 1 else float("inf")
        heapq.heappush(regret_heap, (-regret_value, customer)) # Max-heap by regret

    # Step 3: Insert based on regret
    while regret_heap:
        _, customer = heapq.heappop(regret_heap)
        options = insertion_candidates[customer]
        total_delivery = remaining_deliveries[customer]
        total_pickup = remaining_pickups[customer]

        # try inserting the customer in best positions
        for _, _, idx, _, vehicle, feasible_delivery, feasible_pickup in options:
            if total_delivery == 0 and total_pickup == 0:
                break

            # recalculate feasibility and update load values
            feasible_delivery = min(total_delivery, vehicle.full_vials)
            feasible_pickup = min(total_pickup, vehicle.capacity - (vehicle.full_vials + vehicle.empty_vials + feasible_delivery))
            if feasible_delivery == 0 and feasible_pickup == 0:
                continue

            vehicle.full_vials -= feasible_delivery
            vehicle.empty_vials += feasible_pickup
            vehicle.empty_space = vehicle.capacity - (vehicle.full_vials + vehicle.empty_vials)

            vehicle.route.insert(idx + 1, (customer, feasible_delivery, feasible_pickup, vehicle.current_time))

            # Update future stop times (updates the current time value from above)
            for i in range(idx + 2, len(vehicle.route)):
                prev = vehicle.route[i - 1]
                nxt = vehicle.route[i][0]
                arrival = max(prev[3] + t[prev[0]][nxt], a[nxt])
                vehicle.route[i] = (nxt, vehicle.route[i][1], vehicle.route[i][2], arrival + s[nxt])

            total_delivery -= feasible_delivery
            total_pickup -= feasible_pickup

        remaining_deliveries[customer] = total_delivery
        remaining_pickups[customer] = total_pickup

        # if any demand remains, flag for retry
        if total_delivery > 0 or total_pickup > 0:
            retry_customers.add(customer)

    # Final sweep: retry any removed customers who still have unmet demand
    retry_customers = {
        cust for cust in remaining_deliveries
        if remaining_deliveries.get(cust, 0) > 0 or remaining_pickups.get(cust, 0) > 0
        }

    return solution, retry_customers, remaining_deliveries, remaining_pickups

# Recomputes what demand is still unmet based on solution routes
def recompute_remaining_demands_from_solution(solution, initial_deliveries, initial_pickups):
    remaining_deliveries = initial_deliveries.copy()
    remaining_pickups = initial_pickups.copy()

    for vehicle in solution:
        for node in vehicle.route:
            cust_id, delivered, picked_up, _ = node
            if cust_id == 0:
                continue # Skip depot
            if cust_id in remaining_deliveries:
                remaining_deliveries[cust_id] -= delivered
            if cust_id in remaining_pickups:
                remaining_pickups[cust_id] -= picked_up

    # Clip negative values to 0 (in case more than expected was served)
    for cust in remaining_deliveries:
        remaining_deliveries[cust] = max(0, remaining_deliveries[cust])
    for cust in remaining_pickups:
        remaining_pickups[cust] = max(0, remaining_pickups[cust])

    return remaining_deliveries, remaining_pickups

# Full function for regret split insertion heuristic
def regret_split_insertion(solution, removed_customers, c, t, initial_deliveries, initial_pickups, a, b, s):
    deliveries = deepcopy(initial_deliveries)
    pickups = deepcopy(initial_pickups)

    # Step 2: Perform greedy insertion
    parallel_solution, retry_customers, remaining_deliveries, remaining_pickups = core_regret_split_insertion(
        solution, removed_customers, c, t, initial_deliveries, initial_pickups, a, b, s)

    # Step 3: Recompute actual remaining demand from final solution
    remaining_deliveries, remaining_pickups = recompute_remaining_demands_from_solution(
        parallel_solution, remaining_deliveries, remaining_pickups
    )

    # Step 4: Final retry set
    retry_customers = {
        cust for cust in remaining_deliveries
        if remaining_deliveries[cust] > 0 or remaining_pickups[cust] > 0
    }

    return solution, retry_customers, remaining_deliveries, remaining_pickups

### TEST
# Convert delivery and pickup lists to dictionaries
initial_deliveries = {i: d[i] for i in V_star}
initial_pickups = {i: p[i] for i in V_star}

# 1. Do random removal
modified_random, removed_random, updated_deliveries, updated_pickups = random_removal(
    deepcopy(vehicles_updated), 0.3, deepcopy(initial_deliveries), deepcopy(initial_pickups), t_matrix_np, s
)

# 2. Regret Split!
solution, retry_customers, remaining_deliveries, remaining_pickups = regret_split_insertion(
    modified_random, removed_random, c_matrix_np, t_matrix_np, updated_deliveries, updated_pickups, a, b, s
)

for cust in retry_customers:
        d_amt = remaining_deliveries.get(cust, 0)
        p_amt = remaining_pickups.get(cust, 0)
        print(f"Customer {cust}: Delivery = {d_amt}, Pickup = {p_amt}")

print_vehicle_routes_with_costs(solution, c_matrix_np)

"""# Savings Insertion

The savings insertion heuristic is a clustering-based vehicle routing strategy that merges customer routes based on potential cost "savings" from serving them together rather than individually. It begins by grouping customers into singleton clusters, calculates feasible merges based on time windows, delivery/pickup capacity, and route efficiency, and gradually builds larger routes while injecting depot returns into routes when necessary.
"""

from datetime import datetime

# Resolves any overlapping customers in the initial cluster list.
# Ensures that each customer appears in only one cluster by randomly selecting
# one cluster to keep the customer and removing the customer from the others.

def resolve_cluster_overlap(clusters):
    customer_to_clusters = defaultdict(list)

    # Map each customer to all clusters they appear in
    for cluster in clusters:
        for cust in cluster['customers']:
            customer_to_clusters[cust].append(cluster)

    # For customers in multiple clusters, keep them in one and remove from others
    for cust, cluster_list in customer_to_clusters.items():
        if len(cluster_list) > 1:
            chosen = random.choice(cluster_list)
            for cluster in cluster_list:
                if cluster is not chosen and cust in cluster['customers']:
                    cluster['customers'].remove(cust)

    # Clean up empty clusters
    clusters = [c for c in clusters if c['customers']]
    return clusters

# prints the clusters post-overlap
def print_all_clusters(clusters, label="Current Clusters"):
    print(f"\n{label} — Total: {len(clusters)}")
    for idx, cluster in enumerate(clusters):
        route = cluster.get('route_with_depots', [0] + cluster['customers'] + [0])
        print(f"  Cluster {idx}: {route} (Delivery: {round(cluster['delivery_load'], 2)}, Pickup: {round(cluster['pickup_load'], 2)})")

### CLUSTER CLUSTER MERGE

# Checks whether a proposed route satisfies all time window constraints.
def is_time_feasible_route(route, a, b, s, t):
    time = 0
    current_node = route[0]

    for next_node in route[1:]:
        travel_time = t[current_node][next_node]
        arrival_time = time + travel_time
        arrival_time = max(arrival_time, a[next_node]) # wait if vehicle arrives early

        if arrival_time > b[next_node]: # violated time window
            return False

        time = arrival_time + s[next_node]
        current_node = next_node

    return True

# Checks whether a proposed route satisfies delivery/pickup feasibility based on vehicle capacity
def is_cluster_cluster_capacity_feasible(route, deliveries, pickups, capacity):
    full_vials = 0.75 * capacity
    empty_vials = 0

    for node in route[1:]: # skip starting depot
        if node == 0:
            # Mid-route depot reset
            full_vials = 0.75 * capacity # vehicle starts 75% full
            empty_vials = 0
            continue

        demand_delivery = deliveries.get(node, 0)
        demand_pickup = pickups.get(node, 0)

        # Capacity constraint: can't fulfill full delivery
        if full_vials < demand_delivery:
            return False

        # Simulate delivery
        full_vials -= demand_delivery

        # Check if there's room to pick up all used vials
        space_left = capacity - (full_vials + empty_vials)
        if space_left < demand_pickup:
            return False

        # Simulate pickup
        empty_vials += demand_pickup

    return True

# # Builds a greedy route starting from the depot and inserting nearest unvisited customers
def build_greedy_merge_route(customers, t_matrix):
    route = [0] # start at depot
    unvisited = set(customers)
    current = 0

    while unvisited:
        next_customer = min(unvisited, key=lambda c: t_matrix[current][c])
        route.append(next_customer)
        unvisited.remove(next_customer)
        current = next_customer

    route.append(0) # return to depot
    return route

# Tries to merge two clusters into one feasible route
def cluster_cluster_merge(cluster1, cluster2, deliveries, pickups, capacity, a, b, s, t):
    customers = list(set(cluster1 + cluster2))
    route = build_greedy_merge_route(customers, t)

    # # First attempt: normal route
    if is_time_feasible_route(route, a, b, s, t):
        if is_cluster_cluster_capacity_feasible(route, deliveries, pickups, capacity):
            return route

        # Second attempt: try inserting depot mid-route
        for i in range(1, len(route)-1):
            route_with_depot = route[:i] + [0] + route[i:]
            if is_time_feasible_route(route_with_depot, a, b, s, t) and \
               is_cluster_cluster_capacity_feasible(route_with_depot, deliveries, pickups, capacity):
                return route_with_depot

    return None # merge not feasible

# Iteratively attempts to merge clusters using greedy savings logic and available vehicles
def merge_clusters_stepwise(clusters, deliveries, pickups, vehicles_available, a, b, s, t):
    available_vehicles = sorted(vehicles_available, key=lambda v: v.capacity, reverse=True)
    merged = True

    # Helper: generates arrival times for a route
    def simulate_route_with_timestamps(route):
        time = 0
        current_node = route[0]
        timestamps = [(current_node, time)]

        for next_node in route[1:]:
            travel_time = t[current_node][next_node]
            arrival_time = time + travel_time
            arrival_time = max(arrival_time, a[next_node])
            timestamps.append((next_node, round(arrival_time, 2)))
            time = arrival_time + s[next_node]
            current_node = next_node

        return timestamps

    # computes total demand of a cluster
    def cluster_total_demand(cluster):
        return cluster['delivery_load'] + cluster['pickup_load']

    # keep merging until no more valid merges or no more vehicles
    while merged and len(available_vehicles) > 0:
        merged = False
        clusters.sort(key=cluster_total_demand, reverse=True)

        for i in range(len(clusters)):
            for j in range(i + 1, len(clusters)):
                # Skip clusters that are just singletons
                if len(clusters[i]['customers']) <= 1 or len(clusters[j]['customers']) <= 1:
                    continue

                cluster_i = clusters[i]
                cluster_j = clusters[j]

                cluster1 = cluster_i['customers']
                cluster2 = cluster_j['customers']
                candidate_vehicle = available_vehicles[0]

                # Try to merge the two clusters into a feasible route
                merged_route = cluster_cluster_merge(
                    cluster1, cluster2,
                    deliveries, pickups,
                    candidate_vehicle.capacity,
                    a, b, s, t
                )

                if merged_route:
                    # Build new merged cluster
                    new_customers = [c for c in merged_route if c != 0]
                    new_cluster = {
                        'customers': new_customers,
                        'delivery_load': sum(deliveries.get(c, 0) for c in new_customers),
                        'pickup_load': sum(pickups.get(c, 0) for c in new_customers),
                        'assigned_vehicle': candidate_vehicle
                    }

                    time_str = datetime.now().strftime("%H:%M:%S")
                    print(f"\n [{time_str}] Merged clusters with customers {cluster1} and {cluster2} → Assigned Vehicle {candidate_vehicle.vehicle_id}")
                    print("New Merged Cluster:")
                    print(f"  ➤ {new_customers} (Delivery: {new_cluster['delivery_load']}, Pickup: {new_cluster['pickup_load']})")

                    print("Arrival Timeline:")
                    timestamps = simulate_route_with_timestamps(merged_route)
                    for cust_id, arr_time in timestamps:
                        print(f"     ➤ Node {cust_id}: Arrives at {arr_time:.2f} min")

                    # Remove used vehicle and clusters by object reference
                    available_vehicles.pop(0)
                    clusters.remove(cluster_i)
                    clusters.remove(cluster_j)
                    clusters.append(new_cluster)
                    merged = True
                    break
            if merged:
                break

        print(f"\n Clusters After Merge Step — Total: {len(clusters)}")
        print_all_clusters(clusters)

    return clusters, available_vehicles

### CLUSTER SINGLETON MERGE
def merge_cluster_singletons(clusters, deliveries, pickups, available_vehicles, a, b, s, c, t):

    # Simulates a route and returns timestamped arrival times at each node
    def simulate_route_with_timestamps(route):
        time = 0
        current_node = route[0]
        timestamps = [(current_node, time)]

        for next_node in route[1:]:
            travel_time = t[current_node][next_node]
            arrival_time = max(time + travel_time, a[next_node])
            timestamps.append((next_node, round(arrival_time, 2)))
            time = arrival_time + s[next_node]
            current_node = next_node

        return timestamps

    # Simulates delivery/pickup feasibility along a route, allowing mid-route depot resets
    def simulate_capacity_with_depot_return(route, deliveries, pickups, capacity):
        full = 0.75 * capacity
        empty = 0
        demand_served = {}

        for node in route[1:]:
            if node == 0:
                # Reset capacity at depot (75%)
                full = 0.75 * capacity
                empty = 0
                continue

            d = deliveries.get(node, 0)
            p = pickups.get(node, 0)

            d_fulfilled = min(full, d)
            full -= d_fulfilled

            space_left = capacity - (full + empty)
            p_fulfilled = min(space_left, p)
            empty += p_fulfilled

            if node not in demand_served:
                demand_served[node] = (0, 0)
            prev_d, prev_p = demand_served[node]
            demand_served[node] = (prev_d + d_fulfilled, prev_p + p_fulfilled)

            # If not fully served, force reset at next depot
            if d_fulfilled < d or p_fulfilled < p:
                full = 0.75 * capacity
                empty = 0

        return True, demand_served

    # Separate out singletons (1 customer) and full clusters (2+ customers)
    singletons = [c for c in clusters if len(c['customers']) == 1]
    full_clusters = [c for c in clusters if len(c['customers']) > 1]

    # Track which vehicles are already used
    used_vehicles = set(cluster.get('assigned_vehicle') for cluster in clusters if cluster.get('assigned_vehicle'))

    # Loop over each singleton to find best cluster to merge into
    for singleton in singletons:
        node = singleton['customers'][0]
        best_cluster = None
        best_route = None
        best_cost = float('inf')
        best_demand_served = {}
        best_vehicle = None

        # Try inserting singleton into each full cluster
        for cluster in full_clusters:
            base = cluster['customers']
            vehicle = cluster.get('assigned_vehicle')

            # Assign a vehicle if cluster doesn't already have one
            if not vehicle:
                if available_vehicles:
                    vehicle = available_vehicles.pop(0)
                    used_vehicles.add(vehicle)
                    cluster['assigned_vehicle'] = vehicle
                else:
                    continue

            capacity = vehicle.capacity

            # Try all possible insertion points for the singleton
            for i in range(len(base) + 1):
                trial = [0] + base[:i] + [node] + base[i:] + [0]

                # Skip if time windows are violated
                if not is_time_feasible_route(trial, a, b, s, t):
                    continue

                # Simulate fulfillment and track how much demand is served
                feasible, served = simulate_capacity_with_depot_return(trial, deliveries, pickups, capacity)
                if feasible or node in served:
                    cost = sum(c[trial[i]][trial[i + 1]] for i in range(len(trial) - 1))
                    if cost < best_cost:
                        best_cost = cost
                        best_route = trial
                        best_cluster = cluster
                        best_demand_served = served
                        best_vehicle = vehicle

        # Apply the best merge found, if one exists
        if best_cluster and best_route:
            merged_customers = [n for n in best_route if n != 0]
            best_cluster['customers'] = merged_customers
            best_cluster['delivery_load'] = sum(deliveries.get(n, 0) for n in merged_customers)
            best_cluster['pickup_load'] = sum(pickups.get(n, 0) for n in merged_customers)
            best_cluster['assigned_vehicle'] = best_vehicle

            # Print arrival timeline
            time_str = datetime.now().strftime("%H:%M:%S")
            print(f"\n[{time_str}] Inserted singleton {node} into cluster {best_cluster['customers']}")
            print(f"New Merged Cluster: {merged_customers}")
            print("Arrival Timeline:")
            for n, arr in simulate_route_with_timestamps(best_route):
                print(f"     ➤ Node {n}: Arrives at {arr:.2f} min")

            # Update or remove singleton based on partial or full fulfillment
            d_served, p_served = best_demand_served.get(node, (0, 0))
            remaining_d = deliveries[node] - d_served
            remaining_p = pickups[node] - p_served
            if remaining_d > 0 or remaining_p > 0:
                print(f"Partially served singleton {node}, remaining delivery: {remaining_d}, pickup: {remaining_p}")
                singleton['delivery_load'] = remaining_d
                singleton['pickup_load'] = remaining_p
            else:
                clusters.remove(singleton)

        else:
            print(f"\nCould not insert singleton {node} into any cluster.")

    print(f"\nClusters After Singleton Merge — Total: {len(clusters)}")
    print_all_clusters(clusters)
    return clusters, available_vehicles

# Prints the assigned vehicle (if any) for each cluster
def print_vehicle_assignments(clusters):
    print("\nVehicle Assignments:")
    for i, cluster in enumerate(clusters):
        assigned = cluster.get('assigned_vehicle', None)
        if assigned:
            print(f"  Vehicle {assigned.vehicle_id} → Cluster {i}: {cluster['customers']}")
        else:
            print(f"  Unassigned → Cluster {i}: {cluster['customers']}")

### SINGLETON SINGLETON MERGE
def merge_singleton_singletons(clusters, deliveries, pickups, available_vehicles, a, b, s, c, t):

    # Helper: compute total demand of a cluster
    def total_demand(cluster):
        return cluster['delivery_load'] + cluster['pickup_load']

    # Step 1: Identify all singleton clusters (i.e., clusters with only 1 customer)
    singletons = [c for c in clusters if len(c['customers']) == 1]
    if len(singletons) < 2:
        return clusters, available_vehicles # Nothing to merge

    # Step 2: Sort singleton clusters in descending order of demand (priority to serve largest demand first)
    singletons.sort(key=total_demand, reverse=True)

    # Step 3: Pick the top two highest-demand singletons
    s1, s2 = singletons[:2]
    c1 = s1['customers'][0]
    c2 = s2['customers'][0]

    # Step 4: Compare both route options: depot → c1 → c2 → depot vs depot → c2 → c1 → depot
    route1 = [0, c1, c2, 0]
    route2 = [0, c2, c1, 0]

    cost1 = sum(c[route1[i]][route1[i+1]] for i in range(len(route1)-1))
    cost2 = sum(c[route2[i]][route2[i+1]] for i in range(len(route2)-1))

    best_route = route1 if cost1 < cost2 else route2
    merged_customers = [n for n in best_route if n != 0]

    # Step 5: Assign a vehicle to the new cluster (if any are available)
    if available_vehicles:
        vehicle = available_vehicles.pop(0)
    else:
        print("\nNo available vehicles for singleton-singleton merge.")
        return clusters, available_vehicles

    # Step 6: Build the new merged cluster
    new_cluster = {
        'customers': merged_customers,
        'delivery_load': sum(deliveries.get(n, 0) for n in merged_customers),
        'pickup_load': sum(pickups.get(n, 0) for n in merged_customers),
        'assigned_vehicle': vehicle
    }

    # Step 7: Print timestamp and arrival info
    time_str = datetime.now().strftime("%H:%M:%S")
    print(f"\n[{time_str}] Singleton-Singleton Merge: {c1} + {c2} → {merged_customers} with Vehicle {vehicle.vehicle_id}")
    print("Arrival Timeline:")
    time = 0
    current = 0
    for node in merged_customers:
        travel = t[current][node]
        arrival = max(time + travel, a[node])
        print(f"     ➤ Node {node}: Arrives at {arrival:.2f} min")
        time = arrival + s[node]
        current = node

    # Step 8: Remove old singleton clusters from the list and insert the merged one
    clusters.remove(s1)
    clusters.remove(s2)
    clusters.append(new_cluster)

    # Step 9: Recursively call cluster-singleton merge in case remaining singletons can now be merged into full clusters
    return merge_cluster_singletons(
        clusters,
        deliveries,
        pickups,
        available_vehicles,
        a, b, s, c, t
    )

### RUN THRU FINAL ROUTES
def apply_final_fulfillment(clusters, deliveries, pickups, s, t):
    print("\nApplying Final Fulfillment Across All Clusters...")

    # Loop through each cluster to simulate the actual fulfillment process
    for cluster in clusters:
        vehicle = cluster.get('assigned_vehicle')
        if not vehicle:
            print(f"Skipping unassigned cluster: {cluster['customers']}")
            continue # Skip clusters without an assigned vehicle

        route = [0] + cluster['customers'] + [0]
        full = 0.75 * vehicle.capacity # Initial full vials at start
        empty = 0 # Initial empty vials

        print(f"\nVehicle {vehicle.vehicle_id} Route: {route}")

        # Iterate over each stop in the route (excluding starting depot)
        for idx, node in enumerate(route[1:], start=1):
            if node == 0:
                # Depot reset
                full = 0.75 * vehicle.capacity
                empty = 0
                continue

            # Fulfill delivery
            delivery_needed = deliveries.get(node, 0)
            delivered = min(full, delivery_needed)
            deliveries[node] -= delivered
            full -= delivered

            # Fulfill pickup
            pickup_needed = pickups.get(node, 0)
            space_left = vehicle.capacity - (full + empty)
            picked_up = min(space_left, pickup_needed)
            pickups[node] -= picked_up
            empty += picked_up

            print(f"  ➤ Node {node}: Delivered = {delivered}, Pickup = {picked_up}, Remaining Delivery = {round(deliveries[node], 2)}, Remaining Pickup = {round(pickups[node], 2)}")

def collect_singleton_clusters(clusters):
    singletons = []

    # Collect clusters that contain exactly one customer and have no assigned vehicle
    for cluster in clusters:
        if (
            len(cluster.get('customers', [])) == 1
            and cluster.get('assigned_vehicle') is None
        ):
            singletons.append(cluster)
    return singletons

### INJECTS THE DEPOT IN
def inject_depot_after_last_full_fulfillment(clusters, deliveries, pickups):

    # Inserts a depot visit after the last customer with zero remaining delivery/pickup
    for cluster in clusters:
        vehicle = cluster.get('assigned_vehicle')
        if not vehicle:
            continue

        route = [0] + cluster['customers'] + [0]
        cluster['original_route'] = route[:] # Save the original route!

        # Track the last node where both delivery and pickup are 0
        last_fulfilled_index = 0
        for i in range(1, len(route) - 1): # skip depots
            node = route[i]
            if deliveries.get(node, 0) == 0 and pickups.get(node, 0) == 0:
                last_fulfilled_index = i

        # Inject depot AFTER that node, if it's not the last node before return
        if last_fulfilled_index < len(route) - 2:
            injected_route = route[:last_fulfilled_index + 1] + [0] + route[last_fulfilled_index + 1:]
        else:
            injected_route = route

        cluster['route_with_depots'] = injected_route

def print_cluster_routes_with_injected_depots(clusters):
    # Print all cluster routes after depot injection
    print("\nRoutes After Injecting Depot Post-Fulfillment:")
    for cluster in clusters:
        vehicle = cluster.get('assigned_vehicle')
        if not vehicle:
            continue

        route = cluster.get('route_with_depots', [0] + cluster['customers'] + [0])
        print(f"Vehicle {vehicle.vehicle_id} Route: {route}")

def is_route_time_feasible(route, a, b, s, t_matrix):
    # Check time window feasibility for a route
    current_time = 0
    for i in range(1, len(route)):
        prev_node = route[i - 1]
        curr_node = route[i]
        travel_time = t_matrix[prev_node][curr_node]
        arrival_time = max(current_time + travel_time, a[curr_node])
        if arrival_time > b[curr_node]:
            return False
        current_time = arrival_time + s[curr_node]
    return True

def check_cluster_time_feasibility(clusters, a, b, s, t_matrix):
    # Print whether each cluster's route is feasible after depot injection
    print("\nTime Window Feasibility Check After Depot Injection:")

    for cluster in clusters:
        vehicle = cluster.get('assigned_vehicle')
        if not vehicle:
            print(f"  Skipping unassigned cluster: {cluster['customers']}")
            continue

        route = cluster.get('route_with_depots', [0] + cluster['customers'] + [0])
        feasible = is_route_time_feasible(route, a, b, s, t_matrix)

        status = "Feasible!" if feasible else "Not Feasible"
        print(f"Vehicle {vehicle.vehicle_id} Route: {route} → {status}")

def simulate_full_fulfillment_for_feasible_clusters(clusters, deliveries, pickups, s, t_matrix):
    # Simulates delivery/pickup and prints fulfillment results for feasible routes
    print("\nFull Fulfillment Check for Feasible Routes:")

    for cluster in clusters:
        vehicle = cluster.get('assigned_vehicle')
        if not vehicle:
            continue # skip clusters with no vehicle

        route = cluster.get('route_with_depots', [0] + cluster['customers'] + [0])

        # Check time feasibility first
        if not is_route_time_feasible(route, a, b, s, t_matrix):
            print(f"Vehicle {vehicle.vehicle_id} -> Skipped (Not Feasible)")
            continue

        full = 0.75 * vehicle.capacity
        empty = 0

        local_deliveries = deepcopy(deliveries)
        local_pickups = deepcopy(pickups)

        all_fulfilled = True
        print(f"\nVehicle {vehicle.vehicle_id} Route: {route}")

        for node in route[1:]:
            if node == 0:
                full = 0.75 * vehicle.capacity
                empty = 0
                print("Returned to Depot: Reset full = {:.2f}, empty = {:.2f}".format(full, empty))
                continue

            d_needed = local_deliveries.get(node, 0)
            p_needed = local_pickups.get(node, 0)

            d_fulfilled = min(full, d_needed)
            full -= d_fulfilled
            local_deliveries[node] -= d_fulfilled

            space_left = vehicle.capacity - (full + empty)
            p_fulfilled = min(space_left, p_needed)
            empty += p_fulfilled
            local_pickups[node] -= p_fulfilled

            print(f"  ➤ Node {node}: Delivered = {d_fulfilled}, Pickup = {p_fulfilled}, Remaining Delivery = {local_deliveries[node]}, Remaining Pickup = {local_pickups[node]}")

            if local_deliveries[node] > 0 or local_pickups[node] > 0:
                all_fulfilled = False

        status = "All Demands Fulfilled" if all_fulfilled else "Unmet Demand"
        print(f"Result: {status}")

# Identifies unfulfilled customers and creates new singleton clusters for them.
def collect_unfulfilled_customers(clusters, deliveries, pickups, s, t_matrix, a, b):
    new_clusters = [] # Will hold the output singleton clusters
    residuals = [] # Temporarily collect unmet demand per customer

    for cluster in clusters:
        vehicle = cluster.get('assigned_vehicle')
        if not vehicle:
            continue

        route = cluster.get('route_with_depots', [0] + cluster['customers'] + [0])

        # Only proceed if route is time feasible
        if not is_route_time_feasible(route, a, b, s, t_matrix):
            continue

        full = 0.75 * vehicle.capacity
        empty = 0

        local_deliveries = deepcopy(deliveries)
        local_pickups = deepcopy(pickups)

        for node in route[1:]:
            if node == 0:
                full = 0.75 * vehicle.capacity
                empty = 0
                continue

            d_needed = local_deliveries.get(node, 0)
            p_needed = local_pickups.get(node, 0)

            d_fulfilled = min(full, d_needed)
            full -= d_fulfilled
            local_deliveries[node] -= d_fulfilled

            space_left = vehicle.capacity - (full + empty)
            p_fulfilled = min(space_left, p_needed)
            empty += p_fulfilled
            local_pickups[node] -= p_fulfilled

            # If any remaining, save for new cluster
            if local_deliveries[node] > 0 or local_pickups[node] > 0:
                residuals.append({
                    'customer': node,
                    'delivery_load': round(local_deliveries[node], 2),
                    'pickup_load': round(local_pickups[node], 2)
                })

    # Create clusters from residuals
    for r in residuals:
        new_clusters.append({
            'customers': [r['customer']],
            'delivery_load': r['delivery_load'],
            'pickup_load': r['pickup_load'],
            'assigned_vehicle': None
        })

    return new_clusters

# time infeasible routes!
def analyze_infeasible_clusters(clusters, a, b, s, t_matrix):
    print("\nAnalyzing Time-Infeasible Clusters...")

    for cluster in clusters:
        vehicle = cluster.get('assigned_vehicle')
        if not vehicle:
            continue

        route = cluster.get('route_with_depots') or cluster.get('original_route', [0] + cluster['customers'] + [0])
        if is_route_time_feasible(route, a, b, s, t_matrix):
            continue # only care about infeasible ones

        print(f"\nVehicle {vehicle.vehicle_id} (Infeasible Route): {route}")
        current_time = 0

        for i in range(1, len(route)):
            prev_node = route[i - 1]
            curr_node = route[i]
            travel_time = t_matrix[prev_node][curr_node]
            arrival_time = max(current_time + travel_time, a[curr_node])

            # Print timeline
            print(f"  ➤ Node {curr_node}: ETA = {arrival_time:.2f} (Allowed: {a[curr_node]} - {b[curr_node]})")

            # Check violation
            if arrival_time > b[curr_node]:
                print(f"    Time window violated at Node {curr_node} — Arrival: {arrival_time:.2f}, Latest: {b[curr_node]}")
                break

            current_time = arrival_time + s[curr_node]

# Splits clusters with time-infeasible routes into two parts:
# - Head: the feasible part before the violation (kept in original cluster)
# - Tail: the rest after the violation (turned into new singleton clusters)
def split_infeasible_route_at_violation(clusters, a, b, s, t_matrix):
    new_tail_clusters = []

    for cluster in clusters:
        vehicle = cluster.get("assigned_vehicle")
        if not vehicle:
            continue

        route = cluster.get("route_with_depots", cluster.get("original_route"))
        if is_route_time_feasible(route, a, b, s, t_matrix):
            continue # Only handle infeasible ones

        current_time = 0
        violation_index = None

        for i in range(1, len(route)):
            prev_node = route[i - 1]
            curr_node = route[i]
            travel_time = t_matrix[prev_node][curr_node]
            arrival_time = max(current_time + travel_time, a[curr_node])

            if arrival_time > b[curr_node]:
                violation_index = i
                print(f"Time window violated at Node {curr_node} — Arrival: {arrival_time:.2f}, Latest: {b[curr_node]}")
                break

            current_time = arrival_time + s[curr_node]

        if violation_index is not None:
            # Head: up to last feasible node → return to depot
            head = route[1:violation_index] # skip first depot
            tail = route[violation_index:-1] # skip last depot

            if head:
                cluster['customers'] = head
                cluster['route_with_depots'] = [0] + head + [0]
            else:
                # If nothing left in head, remove the cluster from reuse
                cluster['customers'] = []
                cluster['route_with_depots'] = []

            for node in tail:
                new_tail_clusters.append({
                    'customers': [node],
                    'delivery_load': None, # Fill later based on demand
                    'pickup_load': None,
                    'assigned_vehicle': None
                })

    return new_tail_clusters

# Assigns delivery and pickup demand to newly created singleton clusters.
def assign_demand_to_new_clusters(tail_clusters, deliveries, pickups):
    for cluster in tail_clusters:
        node = cluster['customers'][0]
        cluster['delivery_load'] = round(deliveries.get(node, 0), 2)
        cluster['pickup_load'] = round(pickups.get(node, 0), 2)

def print_singleton_clusters(clusters):
    print("\nSingleton Clusters Detected:")
    for cluster in clusters:
        if len(cluster['customers']) == 1:
            customer = cluster['customers'][0]
            print(f"  ➤ Customer {customer}: Delivery = {cluster.get('delivery_load', '?')}, Pickup = {cluster.get('pickup_load', '?')}")

# Combines all final cluster types into a single list for final processing:
# Includes: main clusters, tail splits, excess demand clusters, and pre-injection singletons.
def consolidate_all_clusters(
    clusters,
    tail_clusters,
    excess_demand_clusters,
    pre_injection_singletons
):
    consolidated = []

    print("\nConsolidating Clusters:")
    cluster_id = 0

    def print_cluster(cluster):
        nonlocal cluster_id
        delivery = round(cluster.get('delivery_load', 0), 2)
        pickup = round(cluster.get('pickup_load', 0), 2)
        vehicle = cluster.get('assigned_vehicle')
        vehicle_str = f"Vehicle {vehicle.vehicle_id}" if vehicle else "Unassigned"

        # Prefer to print the full route if available
        route = cluster.get('route_with_depots') or cluster.get('original_route') or cluster.get('customers', [])
        print(f"  Cluster {cluster_id}: {route} (Delivery: {delivery}, Pickup: {pickup}) — {vehicle_str}")
        cluster_id += 1

    # Add updated main clusters
    for cluster in clusters:
        if cluster.get('customers'):
            consolidated.append(cluster)
            print_cluster(cluster)

    # Add tail clusters
    for cluster in tail_clusters:
        if cluster.get('customers'):
            consolidated.append(cluster)
            print_cluster(cluster)

    # Add residual demand clusters
    for cluster in excess_demand_clusters:
        if cluster.get('customers'):
            consolidated.append(cluster)
            print_cluster(cluster)

    # Add pre-injection singletons
    for cluster in pre_injection_singletons:
        if cluster.get('customers'):
            consolidated.append(cluster)
            print_cluster(cluster)

    return consolidated

# Remove duplicates of singleton clusters
def deduplicate_singleton_clusters(clusters):
    print("\nRemoving Duplicates of Singleton Clusters...")

    seen_singletons = set()
    deduped = []
    cluster_id = 0

    for cluster in clusters:
        customers = cluster.get('customers', [])
        full_route = cluster.get('route_with_depots') or cluster.get('original_route') or customers
        delivery = round(cluster.get('delivery_load', 0), 2)
        pickup = round(cluster.get('pickup_load', 0), 2)
        vehicle = cluster.get('assigned_vehicle')
        vehicle_str = f"Vehicle {vehicle.vehicle_id}" if vehicle else "Unassigned"

        # Check if it's a singleton: [cust], [0, cust, 0], or [0, cust, 0, ...]
        cust_nodes = [c for c in customers if c != 0]
        is_singleton = len(cust_nodes) == 1

        if is_singleton:
            cust = cust_nodes[0]
            key = (cust, delivery, pickup)

            if key not in seen_singletons:
                seen_singletons.add(key)
                deduped.append(cluster)
                print(f"Kept Cluster {cluster_id}: {full_route} (Delivery: {delivery}, Pickup: {pickup}) — {vehicle_str}")
            else:
                print(f"Removed Duplicate: {full_route} (Delivery: {delivery}, Pickup: {pickup}) — {vehicle_str}")
        else:
            deduped.append(cluster)
            print(f"Kept Cluster {cluster_id}: {full_route} (Delivery: {delivery}, Pickup: {pickup}) — {vehicle_str}")

        cluster_id += 1

    print(f"\nTotal After Deduplication: {len(deduped)} Clusters\n")
    return deduped

# Greedy rerouting for singleton clusters
def greedy_route_singletons_with_largest_vehicles(clusters, all_vehicles, a, b, s, t_matrix_np):
    print("\nGreedily Routing Singleton Clusters with Largest Available Vehicle...")

    # Extract vehicle IDs already in use
    used_vehicle_ids = {c['assigned_vehicle'].vehicle_id for c in clusters if c.get('assigned_vehicle')}
    available_vehicles = [v for v in all_vehicles if v.vehicle_id not in used_vehicle_ids]

    if not available_vehicles:
        print("No available vehicle found to assign singleton cluster route.")
        return clusters, None

    # Sort available vehicles by capacity descending
    available_vehicles.sort(key=lambda v: v.capacity, reverse=True)

    # Pull singleton clusters (unassigned only)
    singleton_clusters = [
        c for c in clusters
        if c.get('assigned_vehicle') is None and len([x for x in c['customers'] if x != 0]) == 1
    ]

    if not singleton_clusters:
        print("No unassigned singleton clusters to reroute.")
        return clusters, None

    # Start building one big route if feasible
    cust_list = [c for cluster in singleton_clusters for c in cluster['customers'] if c != 0]
    best_vehicle = available_vehicles[0]
    route = [0] + cust_list + [0]

    # Check time feasibility
    arrival_time = 0
    feasible = True
    for i in range(1, len(route) - 1):
        from_node = route[i - 1]
        to_node = route[i]
        arrival_time = max(arrival_time + s[from_node] + t_matrix_np[from_node][to_node], a[to_node])
        if arrival_time > b[to_node]:
            feasible = False
            break

    if feasible:
        # Combine delivery/pickup loads
        total_delivery = sum(cluster.get('delivery_load', 0) for cluster in singleton_clusters)
        total_pickup = sum(cluster.get('pickup_load', 0) for cluster in singleton_clusters)

        # Save original delivery/pickup per node
        original_delivery = {}
        original_pickup = {}
        for cluster in singleton_clusters:
            node = [c for c in cluster['customers'] if c != 0][0]
            original_delivery[node] = cluster.get('delivery_load', 0)
            original_pickup[node] = cluster.get('pickup_load', 0)

        # Make a new cluster
        new_cluster = {
            'customers': route,
            'route_with_depots': route,
            'delivery_load': total_delivery,
            'pickup_load': total_pickup,
            'assigned_vehicle': best_vehicle,
            'original_delivery': original_delivery,
            'original_pickup': original_pickup
        }

        print(f"Assigned Vehicle {best_vehicle.vehicle_id} → Cluster {route} (Delivery: {total_delivery}, Pickup: {total_pickup})")
        return [c for c in clusters if c not in singleton_clusters] + [new_cluster], new_cluster

    else:
        print("Could not form a time-feasible route with remaining singletons.")
        return clusters, None

def simulate_fulfillment_singleton_cluster(
    cluster,
    s,
    t_matrix_np,
    a,
    b,
    all_vehicles,
    used_vehicle_ids=None
):
    print("\nSimulating Fulfillment for Singleton Cluster (with Dynamic Depot Returns):")

    original_vehicle = cluster.get('assigned_vehicle')
    if not original_vehicle:
        print("No assigned vehicle found for this cluster.")
        return []

    route = cluster.get('route_with_depots', cluster.get('customers', []))
    if not route or len(route) < 3:
        print("Invalid route format.")
        return []

    print(f"Vehicle {original_vehicle.vehicle_id} Route: {route}")

    # Prepare fulfillment state
    full = 0.75 * original_vehicle.capacity
    empty = 0
    current_route = [0]
    sub_routes = []

    local_deliveries = deepcopy(cluster.get('original_delivery', {}))
    local_pickups = deepcopy(cluster.get('original_pickup', {}))

    i = 1
    while i < len(route) - 1:
        node = route[i]

        if node == 0:
            i += 1
            continue

        d_needed = local_deliveries.get(node, 0)
        p_needed = local_pickups.get(node, 0)

        d_fulfilled = min(full, d_needed)
        full -= d_fulfilled
        local_deliveries[node] -= d_fulfilled

        space_left = original_vehicle.capacity - (full + empty)
        p_fulfilled = min(space_left, p_needed)
        empty += p_fulfilled
        local_pickups[node] -= p_fulfilled

        print(f"  ➤ Node {node}: Delivered = {d_fulfilled}, Pickup = {p_fulfilled}, Remaining Delivery = {local_deliveries[node]}, Remaining Pickup = {local_pickups[node]}")

        if local_deliveries[node] > 0 or local_pickups[node] > 0:
            print(f"Unmet demand at node {node}. Ending sub-route before and starting new one from here.")

            current_route.append(0)
            if len(current_route) > 2:
                sub_routes.append(current_route[:])

            current_route = [0, node]
            full = 0.75 * original_vehicle.capacity
            empty = 0
        else:
            current_route.append(node)

        i += 1

    current_route.append(0)
    if len(current_route) > 2:
        sub_routes.append(current_route)

    # Sort sub-routes by total demand
    def total_demand(route):
        return sum(local_deliveries.get(n, 0) + local_pickups.get(n, 0) for n in route if n != 0)

    sub_routes.sort(key=total_demand, reverse=True)

    # ➤ New: Track assigned vehicles correctly
    if used_vehicle_ids is None:
        used_vehicle_ids = set()
    used_vehicle_ids = used_vehicle_ids.copy()
    used_vehicle_ids.add(original_vehicle.vehicle_id)

    sorted_vehicles = sorted(
        [v for v in all_vehicles if v.vehicle_id not in used_vehicle_ids],
        key=lambda v: v.capacity,
        reverse=True
    )
    sorted_vehicles.insert(0, original_vehicle)  # allow reuse only for first

    print(f"\nFinal Sub-Routes Generated: {len(sub_routes)}")
    assigned_clusters = []

    for idx, r in enumerate(sub_routes):
        feasible = is_route_time_feasible(r, a, b, s, t_matrix_np)
        status = "Time Feasible" if feasible else "Time Infeasible"

        if idx < len(sorted_vehicles):
            vehicle = sorted_vehicles[idx]
            used_vehicle_ids.add(vehicle.vehicle_id)
            print(f"Sub-Route {idx}: {r} — {status} — Assigned Vehicle {vehicle.vehicle_id}")
        else:
            vehicle = None
            print(f"Sub-Route {idx}: {r} — {status} — No vehicle available!")

        assigned_clusters.append({
            'customers': r,
            'route_with_depots': r,
            'delivery_load': round(sum(local_deliveries.get(n, 0) for n in r if n != 0), 2),
            'pickup_load': round(sum(local_pickups.get(n, 0) for n in r if n != 0), 2),
            'assigned_vehicle': vehicle
        })

    return assigned_clusters

### Convert to a format suitable for more removals and then write in one large fn.

# route cleanup
def deduplicate_final_clusters(clusters):
    seen = set()
    unique_clusters = []

    for cluster in clusters:
        vehicle_id = getattr(cluster.get('assigned_vehicle'), 'vehicle_id', None)
        route_tuple = tuple(cluster.get('route', []))
        key = (vehicle_id, route_tuple)

        if key not in seen:
            seen.add(key)
            unique_clusters.append(cluster)

    return unique_clusters
'''
def convert_clusters_to_vehicle_solution_with_capacity_check(
    final_clusters,
    all_vehicles,
    original_deliveries,
    original_pickups,
    t_matrix,
    a,
    b,
    s
):
    new_solution = []
    used_vehicle_ids = set()

    for cluster in final_clusters:
        vehicle = cluster.get('assigned_vehicle')
        if vehicle is None:
            print(f"Cluster {cluster['customers']} has no assigned vehicle.")
            continue

        if vehicle.vehicle_id in used_vehicle_ids:
            continue

        new_vehicle = deepcopy(vehicle)

        # Determine base route
        if 'fulfilled_route' in cluster:
            base_route = deepcopy(cluster['fulfilled_route'])
        elif 'route_with_depots' in cluster:
            base_route = []
            for customer in cluster['route_with_depots']:
                delivery = original_deliveries.get(customer, 0)
                pickup = original_pickups.get(customer, 0)
                base_route.append((customer, delivery, pickup, 0.0))
        else:
            base_route = []
            for customer in cluster['customers']:
                if customer == 0:
                    base_route.append((0, 0, 0, 0.0))
                else:
                    delivery = original_deliveries.get(customer, 0)
                    pickup = original_pickups.get(customer, 0)
                    base_route.append((customer, delivery, pickup, 0.0))

        # Recalculate with arrival time and mid-route depot if needed
        new_route = [(0, 0, 0, 0.0)]
        current_time = 0.0
        full_vials = int(vehicle.capacity * 0.75)
        empty_vials = 0

        for i in range(1, len(base_route)):
            prev_node = new_route[-1][0]
            node_id, delivery, pickup, _ = base_route[i]

            # Capacity check
            if full_vials < delivery or (full_vials + empty_vials + delivery - pickup > vehicle.capacity):
                # Insert depot to reload
                depot_return_time = current_time + t_matrix[prev_node][0]
                new_route.append((0, 0, 0, round(depot_return_time, 2)))
                current_time = 0.0
                full_vials = int(vehicle.capacity * 0.75)
                empty_vials = 0
                prev_node = 0  # start from depot now

            travel_time = t_matrix[prev_node][node_id]
            arrival_time = current_time + travel_time

            if arrival_time < a[node_id]:
                arrival_time = a[node_id]
            elif arrival_time > b[node_id]:
                # Insert depot due to time infeasibility
                depot_return_time = current_time + t_matrix[prev_node][0]
                new_route.append((0, 0, 0, round(depot_return_time, 2)))
                current_time = 0.0
                full_vials = int(vehicle.capacity * 0.75)
                empty_vials = 0
                travel_time = t_matrix[0][node_id]
                arrival_time = travel_time
                if arrival_time < a[node_id]:
                    arrival_time = a[node_id]
                elif arrival_time > b[node_id]:
                    print(f"⚠️ STILL infeasible after depot reset at node {node_id}")

            new_route.append((node_id, delivery, pickup, round(arrival_time, 2)))
            current_time = arrival_time + s[node_id]
            full_vials -= delivery
            empty_vials += pickup

        # Final depot return
        last_node = new_route[-1][0]
        final_return_time = current_time + t_matrix[last_node][0]
        new_route.append((0, 0, 0, round(final_return_time, 2)))

        new_vehicle.route = new_route
        cluster['fulfilled_route'] = new_route
        new_solution.append(new_vehicle)
        used_vehicle_ids.add(new_vehicle.vehicle_id)

    return new_solution
'''

def convert_clusters_to_vehicle_solution(
    final_clusters,
    all_vehicles,
    original_deliveries,
    original_pickups,
    t_matrix,
    a,
    b,
    s
):
    new_solution = []
    used_vehicle_ids = set()

    for cluster in final_clusters:
        vehicle = cluster.get('assigned_vehicle')
        if vehicle is None:
            print(f"Cluster {cluster['customers']} has no assigned vehicle.")
            continue

        if vehicle.vehicle_id in used_vehicle_ids:
            continue

        new_vehicle = deepcopy(vehicle)

        # ✨ Use precomputed route_with_depots if available
        if 'route_with_depots' in cluster:
            route = cluster['route_with_depots']
        elif 'fulfilled_route' in cluster:
            route = [stop[0] for stop in cluster['fulfilled_route']]
        else:
            route = cluster['customers']

        # Build the route in expected format: (node_id, delivery, pickup, arrival_time=0.0)
        formatted_route = []
        for node in route:
            delivery = original_deliveries.get(node, 0)
            pickup = original_pickups.get(node, 0)
            formatted_route.append((node, delivery, pickup, 0.0))

        # Prepend depot if missing at start
        if formatted_route[0][0] != 0:
            formatted_route.insert(0, (0, 0, 0, 0.0))

        # Append depot if missing at end
        if formatted_route[-1][0] != 0:
            formatted_route.append((0, 0, 0, 0.0))

        new_vehicle.route = formatted_route
        cluster['fulfilled_route'] = formatted_route
        new_solution.append(new_vehicle)
        used_vehicle_ids.add(vehicle.vehicle_id)

    return new_solution

def print_final_routes_and_compute_total_cost(clusters, c_matrix):
    print("\nFINAL ROUTES & COST SUMMARY:")
    total_fixed_cost = 0
    total_travel_cost = 0

    all_vehicle_ids = set()
    used_vehicle_ids = set()

    for idx, cluster in enumerate(clusters):
        vehicle = cluster.get('assigned_vehicle')
        if not vehicle:
            print(f"  ❓ Cluster {idx}: No vehicle assigned → Route: {cluster.get('customers', [])}")
            continue

        all_vehicle_ids.add(vehicle.vehicle_id)
        route = getattr(vehicle, 'route', [])

        # Only print and compute travel cost if vehicle actually runs
        if len(route) <= 1:
            continue

        route_str = " → ".join(str(stop[0]) for stop in route if stop[0] != 0)
        print(f"  🚚 Vehicle {vehicle.vehicle_id} | Route: {route_str}")

        travel_cost = 0
        for i in range(len(route) - 1):
            from_node = route[i][0]
            to_node = route[i + 1][0]
            travel_cost += c_matrix[from_node][to_node]

        total_travel_cost += travel_cost
        used_vehicle_ids.add(vehicle.vehicle_id)

        print(f"     ↳ Travel Cost: {round(travel_cost, 2)}")

    # Add fixed cost for all vehicles assigned to clusters (used or unused)
    for cluster in clusters:
        vehicle = cluster.get('assigned_vehicle')
        if vehicle and vehicle.vehicle_id in all_vehicle_ids:
            total_fixed_cost += vehicle.cost

    grand_total = total_fixed_cost + total_travel_cost
    print("\nTOTAL COST BREAKDOWN:")
    print(f"  Fixed Vehicle Cost (all assigned): {round(total_fixed_cost, 2)}")
    print(f"  Travel Cost (used only):           {round(total_travel_cost, 2)}")
    print(f"  Grand Total Cost:                  {round(grand_total, 2)}")

    return {
        "fixed_cost": round(total_fixed_cost, 2),
        "travel_cost": round(total_travel_cost, 2),
        "total_cost": round(grand_total, 2)
    }

def vehicles_to_clusters(vehicle_list):
    clusters = []
    for v in vehicle_list:
        cluster = {
            "assigned_vehicle": v,
            "route_with_depots": [stop[0] for stop in v.route],
            "customers": [stop[0] for stop in v.route if stop[0] != 0]
        }
        clusters.append(cluster)
    return clusters

def simulate_capacity_and_insert_depot(final_cleaned_clusters, deliveries, pickups, vehicle_caps, t_matrix, a, b, s):
    updated_clusters = []
    depot_node = 0

    for cluster in final_cleaned_clusters:
        route = cluster.get("route_with_depots", [])
        vehicle = cluster.get("assigned_vehicle")
        if not route or not vehicle:
            updated_clusters.append(cluster)
            continue

        capacity = vehicle_caps[vehicle.vehicle_id]
        full = 0.75 * capacity
        empty = 0
        current_route = [depot_node]
        segments = []

        i = 1
        while i < len(route) - 1:
            node = route[i]
            if node == depot_node:
                i += 1
                continue

            d = deliveries.get(node, 0)
            p = pickups.get(node, 0)

            deliverable = min(full, d)
            full -= deliverable
            remaining_delivery = d - deliverable

            space_left = capacity - (full + empty)
            pickupable = min(space_left, p)
            empty += pickupable
            remaining_pickup = p - pickupable

            current_route.append(node)

            if remaining_delivery > 0 or remaining_pickup > 0:
                current_route.append(depot_node)
                if len(current_route) > 2:
                    segments.append(current_route[:])

                current_route = [depot_node, node]
                full = 0.75 * capacity
                empty = 0

            i += 1

        current_route.append(depot_node)
        if len(current_route) > 2:
            segments.append(current_route)

        # Time feasibility check function
        def is_time_feasible(route):
            current_time = 0.0
            for i in range(1, len(route)):
                prev_node = route[i - 1]
                curr_node = route[i]
                travel_time = t_matrix[prev_node][curr_node]
                current_time += travel_time
                if current_time < a[curr_node]:
                    current_time = a[curr_node]
                elif current_time > b[curr_node]:
                    return False
                current_time += s[curr_node]
            return True

        for seg in segments:
            if is_time_feasible(seg):
                updated_clusters.append({
                    "assigned_vehicle": vehicle,
                    "customers": seg,
                    "route_with_depots": seg
                })
            else:
                first_half = seg[:seg.index(depot_node)+1]
                second_half = seg[seg.index(depot_node)+1:]
                if len(first_half) > 2:
                    updated_clusters.append({
                        "assigned_vehicle": vehicle,
                        "customers": first_half,
                        "route_with_depots": first_half
                    })
                if len(second_half) > 2:
                    updated_clusters.append({
                        "assigned_vehicle": vehicle,
                        "customers": second_half,
                        "route_with_depots": second_half
                    })

    return updated_clusters

# single function!!
def savings_insertion(
    current_solution,
    removed_customers,
    c_matrix_np,
    t_matrix_np,
    original_deliveries,
    original_pickups,
    a, b, s
):
    print("\n✨ Running Full Savings Insertion Pipeline...")

    # Step 0: Initialize demands
    updated_deliveries = deepcopy(original_deliveries)
    updated_pickups = deepcopy(original_pickups)

    # Step 1: Cluster creation from vehicle routes
    clusters = []
    vehicle_cluster_map = {}

    for vehicle in current_solution:
        custs = [stop[0] for stop in vehicle.route if stop[0] != 0]
        if custs:
            d_sum = sum(updated_deliveries[cust] for cust in custs)
            p_sum = sum(updated_pickups[cust] for cust in custs)
            cluster = {'customers': custs, 'pickup_load': p_sum, 'delivery_load': d_sum}
            clusters.append(cluster)
            for c in custs:
                vehicle_cluster_map[c] = cluster

    for customer in removed_customers:
        cluster = {
            'customers': [customer],
            'delivery_load': updated_deliveries.get(customer, 0),
            'pickup_load': updated_pickups.get(customer, 0)
        }
        clusters.append(cluster)
        vehicle_cluster_map[customer] = cluster

    print(f"\nInitial clusters: {len(clusters)}")
    print_all_clusters(clusters, "Initial Clusters (before overlap resolution)")

    # Step 2: Resolve overlaps
    clusters = resolve_cluster_overlap(clusters)
    print(f"\nAfter resolving overlap: {len(clusters)} clusters")
    print_all_clusters(clusters, "Clusters After Overlap Resolution")

    # Step 3: Cluster-cluster merge
    clusters, remaining_vehicles = merge_clusters_stepwise(
        clusters, updated_deliveries, updated_pickups, current_solution, a, b, s, t_matrix_np
    )

    # Step 4: Cluster-singleton merge
    clusters, remaining_vehicles = merge_cluster_singletons(
        clusters, updated_deliveries, updated_pickups, remaining_vehicles, a, b, s, c_matrix_np, t_matrix_np
    )

    print_vehicle_assignments(clusters)

    # Step 5: Singleton-singleton merge
    clusters, remaining_vehicles = merge_singleton_singletons(
        clusters, updated_deliveries, updated_pickups, remaining_vehicles, a, b, s, c_matrix_np, t_matrix_np
    )

    print_vehicle_assignments(clusters)

    # Step 6: Simulate fulfillment
    apply_final_fulfillment(clusters, updated_deliveries, updated_pickups, s, t_matrix_np)

    # Step 7: Inject depot mid-route if needed
    inject_depot_after_last_full_fulfillment(clusters, updated_deliveries, updated_pickups)
    print_cluster_routes_with_injected_depots(clusters)
    check_cluster_time_feasibility(clusters, a, b, s, t_matrix_np)
    simulate_full_fulfillment_for_feasible_clusters(clusters, original_deliveries, original_pickups, s, t_matrix_np)

    # Step 8: Handle unfulfilled demand + infeasibility
    new_unserved_clusters = collect_unfulfilled_customers(clusters, original_deliveries, original_pickups, s, t_matrix_np, a, b)
    print("\nCreated New Clusters for Unserved Customers:")
    for idx, c in enumerate(new_unserved_clusters):
        print(f"  Cluster {idx}: Customer {c['customers'][0]} → Delivery: {c['delivery_load']}, Pickup: {c['pickup_load']}")

    analyze_infeasible_clusters(clusters, a, b, s, t_matrix_np)

    new_tail_clusters = split_infeasible_route_at_violation(clusters, a, b, s, t_matrix_np)
    assign_demand_to_new_clusters(new_tail_clusters, updated_deliveries, updated_pickups)

    print("\nCreated New Clusters for More Unserved Customers:")
    for idx, c in enumerate(new_tail_clusters):
        print(f"  Cluster {idx}: Customer {c['customers'][0]} → Delivery: {c['delivery_load']}, Pickup: {c['pickup_load']}")
    print_singleton_clusters(new_tail_clusters)

    # Step 9: Consolidate all clusters
    all_clusters = consolidate_all_clusters(
        clusters=clusters,
        tail_clusters=new_tail_clusters,
        excess_demand_clusters=new_unserved_clusters,
        pre_injection_singletons=[
            c for c in clusters if len(c.get('customers', [])) == 1 and not c.get('assigned_vehicle')
        ]
    )
    all_clusters_real = deduplicate_singleton_clusters(all_clusters)

    # Step 10: Greedy routing for leftover clusters
    used_vehicle_ids = {c['assigned_vehicle'].vehicle_id for c in all_clusters_real if c.get('assigned_vehicle')}
    unused_vehicles = sorted(
        [v for v in current_solution if v.vehicle_id not in used_vehicle_ids],
        key=lambda v: v.capacity,
        reverse=True
    )
    final_clusters, merged_singleton_cluster = greedy_route_singletons_with_largest_vehicles(
        all_clusters_real, unused_vehicles, a, b, s, t_matrix_np
    )

    # Step 11: Fulfillment simulation if needed
    '''
    sub_clusters = []
    if merged_singleton_cluster:
        sub_clusters = simulate_fulfillment_singleton_cluster(
            merged_singleton_cluster, s, t_matrix_np, a, b, all_vehicles=current_solution
        )
        '''
    used_ids = {c['assigned_vehicle'].vehicle_id for c in final_clusters if c.get('assigned_vehicle')}

    merged_singleton_cluster['original_delivery'] = original_deliveries
    merged_singleton_cluster['original_pickup'] = original_pickups

    sub_clusters = simulate_fulfillment_singleton_cluster(
        merged_singleton_cluster,
        s,
        t_matrix_np,
        a,
        b,
        all_vehicles=current_solution,
        used_vehicle_ids=used_ids
    )
    # Step 12: Final print + cost
    #print_final_routes_and_compute_total_cost(final_clusters + sub_clusters, c_matrix_np)

    # Step 13: Remove duplicate clusters if any
    final_clusters = [
        c for c in final_clusters
        if c.get('customers') != merged_singleton_cluster.get('customers')
    ]

    # Then add the cleaned sub-clusters
    final_cleaned_clusters = deduplicate_final_clusters(final_clusters + sub_clusters)

    # Optional: print cleaned routes and total cost again
    print("\n--- Final Clusters Before Conversion ---")
    for idx, cluster in enumerate(final_cleaned_clusters):
        print(f"\nCluster {idx + 1}:")
        print(f"  Assigned Vehicle: {getattr(cluster.get('assigned_vehicle'), 'vehicle_id', None)}")
        print(f"  Customers: {cluster.get('customers')}")
        if 'route_with_depots' in cluster:
            print(f"  Route with depots: {cluster['route_with_depots']}")
        if 'fulfilled_route' in cluster:
            print(f"  Fulfilled route: {cluster['fulfilled_route']}")
        if 'delivery' in cluster:
            print(f"  Delivery: {cluster['delivery']}")
        if 'pickup' in cluster:
            print(f"  Pickup: {cluster['pickup']}")

    # Step 14: Change format of clusters into better output
    final_cleaned_clusters = convert_clusters_to_vehicle_solution(final_cleaned_clusters, current_solution, original_deliveries, original_pickups, t_matrix_np, a, b, s)

    # Final Step
    updated_deliveries = deepcopy(original_deliveries)
    updated_pickups = deepcopy(original_pickups)

    for vehicle in final_cleaned_clusters:
        for node_id, delivery, pickup, _ in vehicle.route:
            if node_id == 0:
                continue  # skip depot
            if node_id in updated_deliveries:
                updated_deliveries[node_id] = max(0, updated_deliveries[node_id] - delivery)
            if node_id in updated_pickups:
                updated_pickups[node_id] = max(0, updated_pickups[node_id] - pickup)

    # Final Step 2
    clusters_for_fixing = vehicles_to_clusters(final_cleaned_clusters)
    clusters_fixed = simulate_capacity_and_insert_depot(
        clusters_for_fixing,
        original_deliveries,
        original_pickups,
        Q,
        t_matrix_np,
        a, b, s
    )
    return final_cleaned_clusters, removed_customers, updated_deliveries, updated_pickups

### Test case!!

initial_deliveries = {i: d[i] for i in V_star}
initial_pickups = {i: p[i] for i in V_star}

vehicles_updated, remaining_deliveries, remaining_pickups = generate_sequential_solution(
    V, V_star, K, Q, d, p, a, b, s, t_matrix_np, depot=0, distances=distance_matrix_np
)

# Do random removal
modified_random, removed_random, updated_deliveries, updated_pickups = random_removal(
    deepcopy(vehicles_updated), 0.3, deepcopy(initial_deliveries), deepcopy(initial_pickups), t_matrix_np, s
)

# Do savings insertion!
final_clusters, retry_customers, updated_deliveries, updated_pickups = savings_insertion(
    modified_random,
    removed_random,
    c_matrix_np,
    t_matrix_np,
    initial_deliveries,
    initial_pickups,
    a, b, s
)

def print_final_routes_and_compute_total_cost(routes_or_clusters, c_matrix):
    print("\nFINAL ROUTES & COST SUMMARY:")
    total_fixed_cost = 0
    total_travel_cost = 0

    all_vehicle_ids = set()
    used_vehicle_ids = set()
    vehicle_map = {}

    for idx, item in enumerate(routes_or_clusters):
        # Handle both Vehicle and cluster dicts
        if isinstance(item, dict):
            route = item.get('route_with_depots') or item.get('customers', [])
            vehicle = item.get('assigned_vehicle')
        else:
            vehicle = item
            route = [stop[0] for stop in vehicle.route]

        if not vehicle:
            print(f"  ❓ Cluster {idx}: No vehicle assigned → Route: {route}")
            continue

        all_vehicle_ids.add(vehicle.vehicle_id)
        vehicle_map[vehicle.vehicle_id] = vehicle

        if len(route) <= 1:
            continue  # Skip travel cost for unused routes

        used_vehicle_ids.add(vehicle.vehicle_id)
        route_str = " → ".join("Depot" if node == 0 else str(node) for node in route)
        print(f"  🚚 Vehicle {vehicle.vehicle_id} | Route: {route_str}")

        # Compute travel cost
        travel_cost = 0
        for i in range(1, len(route)):
            from_node = route[i - 1]
            to_node = route[i]
            travel_cost += c_matrix[from_node][to_node]
        total_travel_cost += travel_cost

        print(f"     ↳ Travel Cost: {round(travel_cost, 2)}")

    # Add fixed cost for all unique vehicles used/assigned
    for vid in all_vehicle_ids:
        total_fixed_cost += vehicle_map[vid].cost

    grand_total = total_fixed_cost + total_travel_cost
    print("\nTOTAL COST BREAKDOWN:")
    print(f"  Fixed Vehicle Cost (all assigned): {round(total_fixed_cost, 2)}")
    print(f"  Travel Cost (used routes only):    {round(total_travel_cost, 2)}")
    print(f"  Grand Total Cost:                  {round(grand_total, 2)}")

    return {
        "fixed_cost": round(total_fixed_cost, 2),
        "travel_cost": round(total_travel_cost, 2),
        "total_cost": round(grand_total, 2)
    }

print_final_routes_and_compute_total_cost(final_clusters, c_matrix_np)

"""# **Full ALNS**

This ALNS (Adaptive Large Neighborhood Search) heuristic iteratively improves a vehicle routing solution by alternating between removal and insertion operators chosen based on performance-weighted probabilities. After each iteration, it evaluates whether the new solution is accepted or rejected based on cost and demand fulfillment. The algorithm adapts operator selection dynamically and restarts if progress stagnates, helping it escape local minima and find better global solutions.
"""

from typing import List, Tuple, Dict, Any

def detailed_capacity_check_with_logging(
    solution: List[Any],
    deliveries: Dict[int, int],
    pickups: Dict[int, int],
    t_matrix_np: List[List[float]],
    capacities: Dict[int, int],
    service_times: Dict[int, float],
    a: Dict[int, float],
    b: Dict[int, float],
) -> Tuple[bool, List[str]]:
    report = []
    overall_feasible = True

    remaining_delivery = deliveries.copy()
    remaining_pickup = pickups.copy()

    # Track which nodes are visited and by which vehicles
    node_visits = {}
    for vehicle in solution:
        for stop in vehicle.route:
            node = stop[0]
            if node != 0:
                node_visits.setdefault(node, set()).add(vehicle.vehicle_id)

    for vehicle in solution:
        cap = capacities.get(vehicle.vehicle_id, vehicle.capacity)
        full = round(cap * 0.75, 2)
        empty = 0
        vehicle_feasible = True
        route = vehicle.route

        report.append(f"\n🚛 Vehicle {vehicle.vehicle_id} (Capacity {cap} → starts with {full} full)")
        report.append("Route:\n" + " → ".join(str(stop[0]) for stop in route))

        i = 1
        while i < len(route):
            node_id = route[i][0]

            if node_id == 0:
                report.append("Depot: Restocking")
                full = round(cap * 0.75, 2)
                empty = 0
                i += 1
                continue

            delivery_needed = remaining_delivery.get(node_id, 0)
            pickup_needed = remaining_pickup.get(node_id, 0)

            delivery_done = min(full, delivery_needed)
            pickup_room = cap - (full + empty)
            pickup_done = min(pickup_room, pickup_needed)

            full -= delivery_done
            empty += pickup_done
            remaining_delivery[node_id] -= delivery_done
            remaining_pickup[node_id] -= pickup_done

            # Check if node is revisited by this or other vehicles
            will_be_visited_again = any(
                (other.vehicle_id != vehicle.vehicle_id and node_id in [s[0] for s in other.route])
                for other in solution
            ) or any(route[j][0] == node_id for j in range(i + 1, len(route)))

            status = f"Node {node_id}: {delivery_done}D/{pickup_done}P → "
            if delivery_done < delivery_needed or pickup_done < pickup_needed:
                if will_be_visited_again:
                    status += f"⚠️ Partial (will be served again)"
                    overall_feasible = False
                else:
                    status += f"❌ Not fully served and not revisited"
                    overall_feasible = False
                    vehicle_feasible = False
            else:
                status += "✅"
            report.append(status)
            i += 1

        if vehicle_feasible:
            report.append(f"✅ Vehicle {vehicle.vehicle_id} = Feasible")
        else:
            report.append(f"❌ Vehicle {vehicle.vehicle_id} = Infeasible")

    return overall_feasible, report

def check_all_routes_time_feasible(vehicles, t_matrix, a, b, s):
    report = []
    all_feasible = True

    for vehicle in vehicles:
        route = vehicle.route
        arrival_time = 0
        route_feasible = True
        for i in range(1, len(route)):
            prev_node = route[i - 1][0]  # ✅ Extract node ID
            curr_node = route[i][0]     # ✅ Extract node ID
            arrival_time += t_matrix[prev_node][curr_node]
            if arrival_time < a[curr_node]:
                arrival_time = a[curr_node]
            if arrival_time > b[curr_node]:
                route_feasible = False
                all_feasible = False
                report.append(
                    f"❌ Vehicle {vehicle.vehicle_id}: Node {curr_node} arrival {arrival_time:.2f} exceeds latest {b[curr_node]}"
                )
            arrival_time += s[curr_node]
        if route_feasible:
            report.append(f"✅ Vehicle {vehicle.vehicle_id}: Route is time feasible.")

    return all_feasible, report

# Initialize weights and scores for each operator
def initialize_weights_scores(operators):
    scores = {op: 1 for op in operators}
    weights = {op: 1/len(operators) for op in operators}
    return weights, scores

# Update operator performance based on solution quality (best, accept, reject)
def update_operator_weights_and_scores(rem_op, ins_op, outcome, removal_scores, insertion_scores):
    if outcome == "best":
        removal_scores[rem_op] += 15
        insertion_scores[ins_op] += 15
    elif outcome == "accept":
        removal_scores[rem_op] += 5
        insertion_scores[ins_op] += 5
    else: # reject
        removal_scores[rem_op] += 1
        insertion_scores[ins_op] += 1

    total_rem = sum(removal_scores.values())
    total_ins = sum(insertion_scores.values())
    removal_weights = {op: removal_scores[op]/total_rem for op in removal_scores}
    insertion_weights = {op: insertion_scores[op]/total_ins for op in insertion_scores}

    return removal_weights, insertion_weights, removal_scores, insertion_scores

# Ensures all vehicle routes end at the depot
def force_return_to_depot(solution, t):
    for vehicle in solution:
        if len(vehicle.route) > 1 and vehicle.route[-1][0] != 0:
            last_node = vehicle.route[-1][0]
            return_time = t[last_node][0]
            depot_arrival = round(vehicle.current_time + return_time, 2)
            vehicle.route.append((0, 0, 0, depot_arrival))

# Returns a fresh copy of the delivery and pickup demands
def get_fresh_demand():
    return {i: d[i] for i in range(len(d))}, {i: p[i] for i in range(len(p))}

# Calls the selected removal operator
def apply_removal(operator, solution, p, original_deliveries, original_pickups, t, s, distances=None, fixed_costs=None):
    if operator == "random":
        return random_removal(solution, p, original_deliveries, original_pickups, t, s)
    elif operator == "related":
        return related_removal(solution, p, original_deliveries, original_pickups, t, s, distances)
    elif operator == "worst":
        return worst_removal(solution, p, original_deliveries, original_pickups, t, s, distances, fixed_costs)

# Calls the selected insertion operator
def apply_insertion(operator, solution, removed_customers, c, t, deliveries, pickups, a, b, s, original_deliveries, original_pickups):
    if operator == "parallel":
        original_deliveries, original_pickups = get_fresh_demand()
        return parallel_insertion(solution, removed_customers, c, t, original_deliveries, original_pickups, a, b, s)
    elif operator == "regret":
        original_deliveries, original_pickups = get_fresh_demand()
        return regret_split_insertion(solution, removed_customers, c, t, original_deliveries, original_pickups, a, b, s)
    elif operator == "savings":
        original_deliveries, original_pickups = get_fresh_demand()
        return savings_insertion(solution, removed_customers, c, t, original_deliveries, original_pickups, a, b, s)

# Core ALNS loop
def ALNS(initial_solution, original_deliveries, original_pickups, c, t, Q, a, b, s, distances, fixed_costs, T=0.1, MAX_ITERATIONS=50, STAGNATION_LIMIT=5):
    # Helpers
    def summarize_routes(solution):
        return [(v.vehicle_id, [n[0] for n in v.route]) for v in solution]

    def check_unserved_customers(deliveries):
        return [cust for cust, amt in deliveries.items() if amt > 0]

    def total_customers_served(solution):
        return sum(1 for v in solution for stop in v.route if stop[0] != 0)

    # Initialize operator pools
    removal_operators = ["random", "related", "worst"]
    insertion_operators = ["parallel", "regret", "savings"]

    removal_weights, removal_scores = initialize_weights_scores(removal_operators)
    insertion_weights, insertion_scores = initialize_weights_scores(insertion_operators)

    # For logging operator evolution over time
    removal_weights_history = {op: [] for op in removal_operators}
    insertion_weights_history = {op: [] for op in insertion_operators}
    removal_scores_history = {op: [] for op in removal_operators}
    insertion_scores_history = {op: [] for op in insertion_operators}

    cost_history = []

    for op in removal_operators:
        removal_weights_history[op].append(removal_weights[op])
        removal_scores_history[op].append(removal_scores[op])

    for op in insertion_operators:
        insertion_weights_history[op].append(insertion_weights[op])
        insertion_scores_history[op].append(insertion_scores[op])

    # Select operator via roulette wheel sampling
    def roulette_select(weights):
        total = sum(weights.values())
        r = random.uniform(0, total)
        upto = 0
        for key, w in weights.items():
            if upto + w >= r:
                return key
            upto += w

    # Set current and best solutions
    current_solution = deepcopy(initial_solution)
    best_solution = deepcopy(initial_solution)
    force_return_to_depot(current_solution, t)
    force_return_to_depot(best_solution, t)

    cost_current = compute_total_cost(current_solution, c, fixed_costs)
    cost_best = cost_current

    stagnation_counter = 0
    cost_history = [cost_best]

    for iteration in range(MAX_ITERATIONS):
        print(f"\nIteration {iteration + 1}")
        print(f"Current cost: {cost_current}")

        # Fresh copy of demand
        original_deliveries, original_pickups = get_fresh_demand()

        # Apply removal
        rem_op = roulette_select(removal_weights)
        modified, removed_customers, upd_deliveries, upd_pickups = apply_removal(
            rem_op, current_solution, 0.3, original_deliveries, original_pickups, t, s, distances, fixed_costs
        )

        # Apply insertion
        ins_op = roulette_select(insertion_weights)
        try:
            new_solution, retry_customers, new_deliveries, new_pickups = apply_insertion(
                ins_op, modified, removed_customers, c, t, upd_deliveries, upd_pickups, a, b, s, original_deliveries, original_pickups
            )
        except Exception as e:
            print(f"Insertion failed: {e}")
            outcome = "reject"
            stagnation_counter += 1
            # Log current weights/scores anyway
            cost_history.append(cost_best)
            for op in removal_operators:
                removal_weights_history[op].append(removal_weights[op])
                removal_scores_history[op].append(removal_scores[op])
            for op in insertion_operators:
                insertion_weights_history[op].append(insertion_weights[op])
                insertion_scores_history[op].append(insertion_scores[op])
            continue

        # Check if any demand is unfulfilled
        unserved_delivery = check_unserved_customers(new_deliveries)
        unserved_pickup = check_unserved_customers(new_pickups)

        if unserved_delivery or unserved_pickup:
            print("Skipping iteration: Some demands remain unsatisfied.")
            print(f"Unsatisfied Deliveries: {unserved_delivery}")
            print(f"Unsatisfied Pickups: {unserved_pickup}")
            current_solution = deepcopy(best_solution)
            cost_current = compute_total_cost(current_solution, c, fixed_costs)
            outcome = "reject"
            stagnation_counter += 1
        else:
            force_return_to_depot(new_solution, t)
            cost_xt = compute_total_cost(new_solution, c, fixed_costs)
            print(f"New cost: {cost_xt}")

            ratio = (cost_xt - cost_best) / cost_best
            if ratio < T:
                if cost_xt < cost_best:
                    print("New best solution accepted")
                    best_solution = deepcopy(new_solution)
                    cost_best = cost_xt
                    cost_current = cost_xt
                    outcome = "best"
                    stagnation_counter = 0
                else:
                    print("Accepted worse solution within threshold")
                    current_solution = deepcopy(new_solution)
                    cost_current = cost_xt
                    outcome = "accept"
                    stagnation_counter += 1
            else:
                print("Rejected solution")
                outcome = "reject"
                stagnation_counter += 1

        # Simulate and verify
        capacities = {v.vehicle_id: v.capacity for v in current_solution}
        service_times = dict(enumerate(s))

        feasible, log = detailed_capacity_check_with_logging(
            solution=current_solution,
            deliveries=original_deliveries,
            pickups=original_pickups,
            t_matrix_np=t_matrix_np,
            capacities=capacities,
            service_times=service_times,
            a=a,
            b=b
        )
        if not feasible:
            stagnation_counter += 1

            # Track weights and mark as infeasible
            for op in removal_operators:
                removal_weights_history[op].append(removal_weights[op])
                removal_scores_history[op].append(removal_scores[op])
            for op in insertion_operators:
                insertion_weights_history[op].append(insertion_weights[op])
                insertion_scores_history[op].append(insertion_scores[op])

            cost_history.append(cost_best)
            continue

        time_feasible, report = check_all_routes_time_feasible(
            new_solution, t_matrix_np, a, b, s
        )
        for line in report:
            print(line)

        if not time_feasible:
            print("❗ Time window violation found. Skipping solution.")
            outcome = "reject"
            stagnation_counter += 1

            for op in removal_operators:
                removal_weights_history[op].append(removal_weights[op])
                removal_scores_history[op].append(removal_scores[op])
            for op in insertion_operators:
                insertion_weights_history[op].append(insertion_weights[op])
                insertion_scores_history[op].append(insertion_scores[op])

            cost_history.append(cost_best)

            continue

        print(f"Updating scores and weights. Outcome: {outcome}, Removal Operator: {rem_op}, Insertion Operator: {ins_op}")
        removal_weights, insertion_weights, removal_scores, insertion_scores = update_operator_weights_and_scores(
                rem_op, ins_op, outcome, removal_scores, insertion_scores)

        # Track weights and scores
        for op in removal_operators:
            removal_weights_history[op].append(removal_weights[op])
            removal_scores_history[op].append(removal_scores[op])

        for op in insertion_operators:
            insertion_weights_history[op].append(insertion_weights[op])
            insertion_scores_history[op].append(insertion_scores[op])

        print(f"Updated removal weights: {removal_weights}")
        print(f"Updated insertion weights: {insertion_weights}")

        cost_history.append(cost_xt if 'cost_xt' in locals() else cost_current)

        if stagnation_counter >= STAGNATION_LIMIT:
            print("Stagnation detected. Restarting from initial solution")
            current_solution = deepcopy(initial_solution)
            cost_current = compute_total_cost(current_solution, c, fixed_costs)
            stagnation_counter = 0

    print("\n🏁 Finished ALNS.")
    print(f"Best cost found: {cost_best}")
    for vehicle in best_solution:
        print(f"Vehicle {vehicle.vehicle_id}: {vehicle.route}")

    return best_solution, cost_history, removal_weights_history, insertion_weights_history, removal_scores_history, insertion_scores_history

"""# **Test on Michigan Parameters**"""

initial_solution, initial_deliveries, initial_pickups = generate_sequential_solution(
    V, V_star, K, Q, d, p, a, b, s, t_matrix_np, depot=0, distances=distance_matrix_np
)

print_final_routes_and_compute_total_cost(initial_solution, c_matrix_np)

MAX_RETRIES = 100  # just in case it never converges, add a safety cap
attempt = 1

while attempt <= MAX_RETRIES:
    print(f"\n🔁 Attempt {attempt}: Running ALNS...")

    final_solution, cost_history, removal_weights_history, insertion_weights_history, removal_scores_history, insertion_scores_history = ALNS(
        initial_solution=initial_solution,
        original_deliveries=initial_deliveries,
        original_pickups=initial_pickups,
        c=c_matrix_np,
        t=t_matrix_np,
        Q=Q,
        a=a,
        b=b,
        s=s,
        distances=distance_matrix_np,
        fixed_costs=fixed_costs,
        T=0.1,
        MAX_ITERATIONS=100,
        STAGNATION_LIMIT=3
    )

    # Build input for feasibility checks
    capacities = {v.vehicle_id: v.capacity for v in final_solution}
    service_times = dict(enumerate(s))
    deliveries = dict(enumerate(d))
    pickups = dict(enumerate(p))

    # Check feasibility
    is_capacity_feasible, cap_log = detailed_capacity_check_with_logging(
        solution=final_solution,
        deliveries=deliveries,
        pickups=pickups,
        t_matrix_np=t_matrix_np,
        capacities=capacities,
        service_times=30,
        a=a,
        b=b
    )
    print("\n📦 Capacity Feasibility:")
    for line in cap_log:
        print(line)

    is_time_feasible, time_log = check_all_routes_time_feasible(
        vehicles=final_solution,
        t_matrix=t_matrix_np,
        a=a,
        b=b,
        s=s
    )
    print("\n⏰ Time Window Feasibility:")
    for line in time_log:
        print(line)

    if is_capacity_feasible and is_time_feasible:
        print(f"\n✅ Feasible solution found on attempt {attempt} with cost {compute_total_cost(final_solution, c_matrix_np, fixed_costs)}")
        break
    else:
        print(f"\n❌ Infeasible solution on attempt {attempt}. Retrying...\n")
        attempt += 1

print(d)
print(p)

for w in removal_weights_history:
    print(w, removal_weights_history[w])

for w in insertion_weights_history:
    print(w, insertion_weights_history[w])

# Plot cost history and computed cost
plt.figure(figsize=(12, 6))
plt.plot(cost_history, marker='o', label='Accepted Solution Cost', linewidth=2)
plt.title("Cost Evolution Over Iterations")
plt.xlabel("Iteration")
plt.ylabel("Total Cost")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

plt.plot(removal_weights_history["random"], label="Random", linewidth=2)
plt.plot(removal_weights_history["related"], label="Related", linewidth=2)
plt.plot(removal_weights_history["worst"], label="Worst", linewidth=2)
plt.legend()
plt.xlabel("Iteration")
plt.ylabel("Weight")
plt.title("Weight Evolution of Removal Operators Over Iterations")
plt.grid(True)
plt.show()

plt.plot(insertion_weights_history["parallel"], label="Parallel", linewidth=2)
plt.plot(insertion_weights_history["regret"], label="Regret", linewidth=2)
plt.plot(insertion_weights_history["savings"], label="Savings", linewidth=2)
plt.legend()
plt.xlabel("Iteration")
plt.ylabel("Weight")
plt.title("Weight Evolution of Insertion Operators Over Iterations")
plt.grid(True)
plt.show()